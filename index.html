<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Roadmaps</title>
<link rel="stylesheet" href="http://app.classeur.io/base-min.css" />
<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body><div class="export-container"><h1 id="roadmaps-for--web-prolog-and-the-pengines-v2-framework">Roadmaps for  Web Prolog and the Pengines V2 Framework</h1>
<h2 id="abstract">Abstract</h2>
<ul>
<li>Design an extension of Prolog called Web Prolog
<ul>
<li>Characterize it as a language for interoperation between Web Prolog processes running on a peer-to-peer network of  nodes, as well as a language for programming the interaction with human users</li>
<li>Pick a sizable set of builtin predicates from ISO Prolog</li>
<li>Pick from Prolog Commons</li>
<li>Pick concurrency-oriented features from Erlang</li>
<li>Develop a pengines library in Web Prolog ‚Ä¶</li>
<li>‚Ä¶ on top of which a Prolog Web can be built</li>
<li>Support feature structures (dicts that are sideways open)</li>
<li>Support native syntax web formats such as RDF, JSON, XML, HTML</li>
<li>Support import and export of web formats (e.g. RDF, RuleML)</li>
<li>Develop a system of profiles describing features that are supported by an actual running instance (tabling, etc.)</li>
<li>Place an ad - ‚Äúopen source front-end programmer wanted‚Äù (e.g. at <a href="https://openhatch.org">https://openhatch.org</a>)</li>
<li>Showcase different uses of Pengines<br>
* Collaborative programming<br>
* Non-Prolog pengines. A library?<br>
* RESTful API on top of pengines</li>
</ul>
</li>
<li>Develop a W3C standard for Web Prolog
<ul>
<li>Propose a W3C Community group</li>
<li>Choose Jan Wielemaker to be language dictator</li>
<li>Publish a report</li>
<li>Write a journal paper about Web Prolog</li>
<li>Try to take it to the next level, a W3C working group
<ul>
<li>Form a consortium</li>
<li>Develop tests</li>
</ul>
</li>
</ul>
</li>
<li>Build an SWI-Prolog implementation of Web Prolog and the Pengines V2 framework</li>
<li>Form a non-profit company supporting the development</li>
<li>Write a book and/or an online tutorial for Web Prolog and the Pengines V2 framework</li>
<li>Web application (server-side) framework -&gt; programming in the large</li>
<li>Target interoperability of implementations rather than portability</li>
</ul>
<h2 id="table-of-contents">Table of contents</h2>
<div class="toc"><ul><li><a href="#roadmaps-for--web-prolog-and-the-pengines-v2-framework">Roadmaps for  Web Prolog and the Pengines V2 Framework</a><ul><li><a href="#abstract">Abstract</a></li><li><a href="#table-of-contents">Table of contents</a></li><li><a href="#a-roadmap-needs-a-vision-and-a-focus">A roadmap needs a vision and a focus</a></li><li><a href="#the-world-wide-web">The World Wide Web</a><ul><li><a href="#the-web-is-worked-on">The Web is worked on</a></li><li><a href="#the-web-is-mobile">The Web is mobile</a></li><li><a href="#the-web-of-coined-catchy-phrases">The Web of Coined Catchy Phrases</a></li><li><a href="#the-web-is-multimodal">The Web is multimodal</a><ul><li><a href="#output">Output</a></li><li><a href="#input">Input</a></li></ul></li></ul></li><li><a href="#where-we-stand-right-now">Where we stand right now</a><ul><li><a href="#librarypengines">library(pengines)</a></li><li><a href="#swish">SWISH</a></li><li><a href="#other-apps">Other apps</a></li><li><a href="#the-prolog-web">The Prolog Web</a><ul><li><a href="#how-about-some-hands-on-experience">How about some hands-on experience?</a></li><li><a href="#logic-web">Logic Web</a></li><li><a href="#logic-web-user-interfaces">Logic Web user interfaces</a></li><li><a href="#a-word-about-restfulness">A word about RESTfulness</a></li><li><a href="#pengines-are-agents">Pengines are agents</a></li><li><a href="#a-thought-experiment">A thought experiment</a></li></ul></li></ul></li><li><a href="#problems-with-pengines">Problems with Pengines</a></li><li><a href="#a-new-language">A new language</a></li><li><a href="#comparing-prolog-and-erlang">Comparing Prolog and Erlang</a><ul><li><a href="#erlang----the-missing-parts">Erlang -- the missing parts</a></li><li><a href="#erlang----the-good-parts">Erlang -- the good parts</a></li><li><a href="#erlang-and-prolog-from--a-bird‚Äôs-eye-view">Erlang and Prolog from  a bird‚Äôs eye view</a></li><li><a href="#a-sip-of-elixir">A sip of Elixir</a></li><li><a href="#popularity-contest-erlang-vs-prolog">Popularity contest: Erlang vs Prolog</a></li></ul></li><li><a href="#web-prolog">Web Prolog</a><ul><li><a href="#rdf">RDF</a></li><li><a href="#json">JSON</a></li><li><a href="#xml">XML</a></li><li><a href="#pengines">Pengines</a></li><li><a href="#prolog-extended-with-erlang-constructs">Prolog extended with Erlang constructs</a></li><li><a href="#web-prolog-borrowing-from-erlang">Web Prolog borrowing from Erlang</a><ul><li><a href="#spawning-sending-and-receiving">Spawning, sending and receiving</a></li><li><a href="#monitoring-and-linking">Monitoring and linking</a></li></ul></li><li><a href="#web-prolog-and-pengines-v2-use-cases">Web Prolog and Pengines V2 use cases</a><ul><li><a href="#computational-linguistics">Computational linguistics</a></li><li><a href="#web-based-multimodal-dialog-systems">Web-based multimodal dialog systems</a></li><li><a href="#graphical-user-interfaces">Graphical user interfaces</a></li><li><a href="#card-based-user-interfaces">Card-based user interfaces</a></li><li><a href="#robot-programming">Robot programming</a></li><li><a href="#games">Games</a></li><li><a href="#home-automation">Home automation</a></li><li><a href="#expert-systems">Expert systems</a></li><li><a href="#digital-humanities">Digital humanities</a></li><li><a href="#domain-specific-languages">Domain Specific Languages</a></li><li><a href="#research-demos">Research demos</a></li></ul></li><li><a href="#the-idea">The idea</a><ul><li><a href="#logic-and-protocols">Logic and Protocols</a></li></ul></li></ul></li><li><a href="#programming-examples">Programming examples</a><ul><li><a href="#spawning-sending-and-receiving-1">Spawning, sending and receiving</a></li><li><a href="#stateful-servers">Stateful servers</a></li><li><a href="#current-fridge-is-broken">Current fridge is broken</a></li><li><a href="#a-universal-stateful-server-with-hot-code-swapping">A universal stateful server with hot code swapping</a></li><li><a href="#concurrency">Concurrency</a></li><li><a href="#web-prolog-and-pengines-v2-use-cases-1">Web Prolog and Pengines V2 use cases</a><ul><li><a href="#computational-linguistics-1">Computational linguistics</a></li><li><a href="#web-based-multimodal-dialog-systems-1">Web-based multimodal dialog systems</a></li><li><a href="#graphical-user-interfaces-1">Graphical user interfaces</a></li><li><a href="#card-based-user-interfaces-1">Card-based user interfaces</a></li><li><a href="#robot-programming-1">Robot programming</a></li><li><a href="#games-1">Games</a></li><li><a href="#home-automation-1">Home automation</a></li><li><a href="#expert-systems-1">Expert systems</a></li><li><a href="#digital-humanities-1">Digital humanities</a></li><li><a href="#domain-specific-languages-1">Domain Specific Languages</a></li><li><a href="#research-demos-1">Research demos</a></li></ul></li><li><a href="#the-idea-1">The idea</a><ul><li><a href="#logic-and-protocols-1">Logic and Protocols</a></li></ul></li></ul></li><li><a href="#programming-examples-1">Programming examples</a><ul><li><a href="#spawning-sending-and-receiving-2">Spawning, sending and receiving</a></li><li><a href="#stateful-servers-1">Stateful servers</a></li><li><a href="#current-fridge-is-broken-1">Current fridge is broken</a></li><li><a href="#a-universal-stateful-server-with-hot-code-swapping-1">A universal stateful server with hot code swapping</a></li><li><a href="#concurrency-1">Concurrency</a></li><li><a href="#non-determinism">Non-determinism</a><ul><li><a href="#warming-up">Warming up</a></li><li><a href="#the-plap-protocol-the-pengines-protocol">The PLAP protocol (The Pengines Protocol)</a></li><li><a href="#implementing-pengines-in-web-prolog">Implementing Pengines in Web Prolog</a></li></ul></li><li><a href="#when-to-use-a-pengine">When to use a pengine?</a></li><li><a href="#implementing-ndrpc">Implementing NDRPC</a></li><li><a href="#non-prolog-pengines">Non-Prolog pengines</a></li></ul></li><li><a href="#designing-web-prolog">Designing Web Prolog</a></li><li><a href="#learnability">Learnability</a></li><li><a href="#implementations">Implementations</a><ul><li><a href="#summary-of-implementation-in-swi-prolog">Summary of implementation in SWI-Prolog</a></li><li><a href="#swi-prolog-roadmap">SWI-Prolog roadmap</a><ul><li><a href="#my-own-suggestions">My own suggestions:</a></li></ul></li><li><a href="#in-erlang">In Erlang</a></li><li><a href="#in-java">In Java</a></li></ul></li><li><a href="#standardisation">Standardisation</a></li><li><a href="#the-pengines-v2-framework">The Pengines V2 framework</a></li><li><a href="#branding">Branding</a><ul><li><ul><li><a href="#the-war-of-the-engines">The War of the Engines</a></li></ul></li></ul></li><li><a href="#financing">Financing</a></li><li><a href="#creating-community">Creating community</a></li><li><a href="#deliverables">Deliverables</a></li><li><a href="#personal-committment">Personal committment</a></li></ul></li><li><a href="#personal-plan">Personal plan</a><ul><li><a href="#references">References</a></li></ul></li><li><a href="#scrap">Scrap</a></li></ul></div><h2 id="a-roadmap-needs-a-vision-and-a-focus">A roadmap needs a vision and a focus</h2>
<p>This document tries to mix no less than four roadmaps</p>
<ul>
<li>Web Prolog</li>
<li>SWI-Prolog</li>
<li>Pengines V2</li>
<li>Personal roadmap</li>
</ul>
<p>From the SWI-Prolog manual at <a href="http://www.swi-prolog.org/pldoc/man?section=swiprolog">http://www.swi-prolog.org/pldoc/man?section=swiprolog</a>:</p>
<blockquote>
<p>Most implementations of the Prolog language are designed to serve a limited set of use cases. SWI-Prolog is no exception to this rule. SWI-Prolog positions itself primarily as a Prolog environment for ‚Äúprogramming in the large‚Äù and use cases where it plays a central role in an application, i.e., where it acts as ‚Äúglue‚Äù between components. At the same time, SWI-Prolog aims at providing a productive rapid prototyping environment. Its orientation towards programming in the large is backed up by scalability, compiler speed, program structuring (modules), support for multithreading to accommodate servers, Unicode and interfaces to a large number of document formats, protocols and programming languages. Prototyping is facilitated by good development tools, both for command line usage as for usage with graphical development tools. Demand loading of predicates from the library and a ‚Äòmake‚Äô facility avoids the requirement for using declarations and reduces typing.</p>
</blockquote>
<p>See also: <a href="http://www.swi-prolog.org/Directions.txt">http://www.swi-prolog.org/Directions.txt</a>:</p>
<blockquote>
<p>With SWI-Prolog, we want to provide a language that satisfies the needs of academic and industrial application programmers. SWI-Prolog is a dialect of Prolog because we believe that the logic foundation provides a good basis for many relatively simple reasoning tasks seen in  applications. Its reflective capabilities as well as its `program is data‚Äô view makes it an ideal platform for domain specific languages (DSLs) or micro languages, which allows for concise description of application knowledge and separation of this knowledge from how it is applied. And, of course, Prolog provides a safe environment, free of crashes and memory leaks.</p>
</blockquote>
<p>First, we would like to say something about roadmaps in general. In our view, a roadmap could be much more than a list of features to be implemented.</p>
<p><a href="http://www.swi-prolog.org/Roadmap.txt">http://www.swi-prolog.org/Roadmap.txt</a></p>
<ul>
<li>Web based IDE</li>
<li>Towards tabling: delimited continuations and tries data structures</li>
<li>Sort out proper compilation of last-call optimization in the ZIP VM (Bart gave me some ideas).</li>
<li>(Voluntary, partial) typing and static analysis</li>
<li>Web issues: HTTP 2.0, SOAP, Oauth, HTTPS (making it usable for non-gods), ‚Ä¶</li>
<li>Social network login plugin (now only Google)</li>
<li>Tutorials/book</li>
<li>Enhance annotation/discussion on website (allow commenting on annotations, hide down voted comments, etc). Could be a proper library.</li>
</ul>
<p>There is also a Github repository at: <a href="https://github.com/SWI-Prolog/roadmap/issues">https://github.com/SWI-Prolog/roadmap/issues</a>.</p>
<p>First we have to agree on a vision and a goal. This goal should be the main focus. How do we get to where we want to be? This is the roadmap. In the words of the Wikipedia entry on <em>Technology roadmap</em>:<sup class="footnote-ref"><a href="#fn1" id="fnref1">1</a></sup></p>
<blockquote>
<p>A technology roadmap is a plan that matches short-term and long-term goals with specific technology solutions to help meet those goals.</p>
</blockquote>
<blockquote>
<p>[A] vision should exist and it must be clear that the roadmap can support that vision. If the vision does not exist one should be developed and clearly stated.</p>
</blockquote>
<p>A vision and a focus is not necessarily the same thing. One can have an unfocused vision, and probably also a focus that lacks vision. We want both ‚Äì a focused vision.</p>
<p>In the present paper, I would like to sketch both a vision and a roadmap, a way to move Prolog (or <em>some</em> of it) in a direction which we think is very exciting, yet realisable within a relatively short timeframe of (say) five years. It involves extending Prolog with a small number of Erlang-inspired predicates for concurrent programming, thus enabling the use of idioms, design patterns and programming techniques that have been developed for Erlang. It also involves an even sharper focus on the Web, a focus that SWI-Prolog to a great extent already has thanks to Jans work on libraries for HTTP, XML, HTML, JSON, RDF and pengines. Prolog and the Web is a marriage made in heaven, and could, in our opinion, mean the revival of Prolog. We think the focus should be on the Web, and our vision to build something that is good for the Web.</p>
<h2 id="the-world-wide-web">The World Wide Web</h2>
<p>Proofs:</p>
<ul>
<li>The popularity of the JavaScript programming language</li>
<li>The proliference of W3C device APIs</li>
<li>The rise of the Mobile Web</li>
</ul>
<h3 id="the-web-is-worked-on">The Web is worked on</h3>
<h3 id="the-web-is-mobile">The Web is mobile</h3>
<h3 id="the-web-of-coined-catchy-phrases">The Web of Coined Catchy Phrases</h3>
<h3 id="the-web-is-multimodal">The Web is multimodal</h3>
<p>Web standards for multimodal user interfaces</p>
<p>There are a large number of W3C standards for UI-related things. The following list was compiled by a student of mine (David Junger).</p>
<h4 id="output">Output</h4>
<dl>
       <dt>Text</dt>
       <dd>Web pages' basic form of expression, text can be generated, styled, and rendered in rich detail with modern <abbr title="Cascading Style Sheet">CSS</abbr>, especially for visual media but also to some extent as braille or speech on devices that support it (see Speech below). Text tracks <a href="#refWebVTT">[WebVTT]</a> synchronized to audio/video streams no longer even require scripting.</dd>
       <dt>Speech</dt>
       <dd>While most browsers support declarative HTML-to-speech to some degree, they do so in their own way and have little or no support for aural CSS <a href="#refAuralCSS">[AuralCSS]</a>. The standard Web Speech Synthesis API <a href="#refSpeechAPI">[WebSpeech]</a>, however, is being implemented and promises interoperability and finer control to application developers.</dd>
       <dt>Graphics</dt>
       <dd>Modern browsers offer several ways to render rich animated graphics, declaratively with HTML and SVG, or programmatically with the Canvas. The latter supports 3D rendering with WebGL <a href="#refWebGL">[WebGL]</a>, which enables declarative 3D markup through libraries (the plug-in era is ending <a href="#ref03D">[future of O3D]</a>).</dd>
       <dt>Audio/Video</dt>
       <dd>All major browsers support native audio/video playback <a href="#refHTMLMedia">[HTMLMedia]</a> in a standardized (but not interoperable due to disagreements on codecs) way. Moreover, some browsers are rolling out an <abbr title="Application Programming Interface">API</abbr> for manipulating the audio stream <a href="#refAudioAPI">[WebAudio]</a> directly, which, among other things, promises better performance for custom speech synthesis.</dd>
       <dt>Haptics</dt>
       <dd>A <abbr title="World Wide Web Consortium">W3C</abbr> community group has been started to standardize APIs allowing Web applications to access the haptics capabilities of devices that have them. It is reasonable to expect that, if haptic feedback touchscreens spread widely, that API will be ready sooner rather than later. , for the Vibration API <a href="#refVibrationAPI">[Vibration]</a> is widely implemented on mobile browsers!</dd>
   </dl>
<h4 id="input">Input</h4>
<dl>
       <dt>Text</dt>
       <dd>Text entry is nothing new on the Web (or on computers in general). Any device whose physical input is translated into text can be used in decades-old HTML form elements. That means keyboard entry, but also platform-specific speech recognition, handwriting recognition, barcode scanners, etc.</dd>
       <dt>Keystrokes</dt>
       <dd>Generated by keyboards, gamepads, mice, trackpads, but also eye-blinks, voice commands or hand gestures on platforms that recognize them. As long as it comes out as a keystroke or click event, Web applications can handle it as <abbr title="Document Object Model">DOM</abbr> Events <a href="#refDOMEvents">[DOMEvent]</a>.</dd>
       <dt>Gamepads</dt>
       <dd>Speaking of gamepads, there is a generic API <a href="#refGamepadAPI">[Gamepad]</a> for accessing them, with normalized floating-point values for both their axes and buttons, and events when a gamepad is (dis)connected.</dd>
       <dt>Pointing</dt>
       <dd>Web applications support pointing (and scrolling) devices as long as they behave like a mouse, or, more recently, as a touchpad. There is no support for pointing in 3D, but multiple simultaneous fingers can be tracked, and support for more generic multipointer <a href="#refPointerEvents">[PointerEvents]</a> is on the horizon.</dd>
       <dt>Gestures</dt>
       <dd>It is possible to implement video-based body tracking in the browser but the results are only at a proof-of-concept level. The dedicated hardware and software required for high precision tracking have gotten <a class="wiki" href="http://en.wikipedia.org/wiki/Kinect">into consumer hands<img title="Wikipedia link" alt="(Wikipedia link)" src="wiki.png"></a> recently, and in the near future that this thesis anticipates, the processed input will definitely be available to Web browsers and the technology will be more widespread. In the meantime, the only well-supported gestures are finger gestures on touchscreens.</dd>
       <dt>Geolocation</dt>
       <dd>Location information is available through a standardized API <a href="#refGeoAPI">[Geolocation]</a> for devices that support it, regardless of the method of location (usually GPS or Wifi-based). It is widely used by commercial Web sites.</dd>
       <dt>Acceleration</dt>
       <dd>Many devices come with motion sensors that can tell when the device is moved or rotated. The DeviceOrientation and DeviceMotion <a href="#refAcceleration">[DeviceMotion]</a> <abbr title="Document Object Model">DOM</abbr> Events allow Web content to know all about it.</dd>
       <dt>Audio</dt>
       <dd>Live audio capture <a href="#refCaptureAPI">[MediaCapture]</a> and manipulation <a href="#refAudioAPI">[WebAudio]</a> have standard APIs and are being rolled out while I'm writing my thesis.</dd>
       <dt>Speech</dt>
       <dd>Speech recognition also has a standard API <a href="#refSpeechAPI">[WebSpeech]</a> that browsers are beginning to support. The recognition engine is platform-specific but, if the API is followed by implementers, Web applications will enjoy interoperability anyway. It is not equivalent to text entry because, unlike platform-based speech recognition, the application gets a lot more than just a string: it can specify recognition grammars, gets a list of alternative recognition strings as well as quick intermediate results, and possibly some prosodic information.</dd>
       <dt>Video</dt>
       <dd>Browsers are beginning to support live video capture <a href="#refCaptureAPI">[MediaCapture]</a> from the device's camera. The stream is encoded by the platform but can be decoded by passing it to a <code>&lt;video&gt;</code> element. It could be used to implement various image analysis and recognition algorithms.</dd>
       <dt>More</dt>
       <dd>An exhaustive list of all APIs under development would be outdated the moment it was written. Instead, have a look at the <a href="http://www.w3.org/2009/dap/#roadmap">Device APIs Working Group's roadmap</a>.</dd>
   </dl>    
<h2 id="where-we-stand-right-now">Where we stand right now</h2>
<p>We begin with a quote from Paul Graham, English computer scientist, venture capitalist, and essayist:</p>
<blockquote>
<p>I think a lot of the most exciting new applications that get written in the next twenty years will be Web-based applications, meaning programs that sit on the server and talk to you through a Web browser. And to write these kinds of programs we may need some new things. (Paul Graham, 2001)</p>
</blockquote>
<p>In the Prolog world, during the fifteen years since Paul Graham wrote the passage quoted above, Jan has surely done his best to provide SWI-Prolog with many ‚Äúnew things‚Äù of great utility and importance for Prolog programmers writing Web-based applications. Most such ‚Äúthings‚Äù have seen the world in the form of new program <em>libraries</em> ‚Äì an HTTP library, an XML library, an HTML library, a Websockets library, a JSON library, an RDF triple store, and so on.</p>
<p>Jan and his associates have also built the ClioPatria framework, a SWI-Prolog application that integrates the SWI-Prolog libraries for RDF and HTTP services into a ready to use Semantic Web server that allows for serving an entire RDF-based Web application from a single executable. ClioPatria furthermore features an extensible Web frontend to manage the server, browse the data, query the data using Prolog and a Git-based plugin manager. The ability to query RDF using Prolog provides query composition and smooth integration with application logic.</p>
<p>Alongside the libraries and the ClioPatria framework, Jan has introduced extensions such as <em>strings</em> (i.e. compact representations of character sequences that live on the global stack) and <em>dicts</em> (i.e. key-value associations) in SWI-Prolog V7. They can be seen as important and (perhaps in some circles provocative) even further steps away from ISO Prolog and as moves towards a programming language better serving the Web.</p>
<p>Some people are worried that Jan‚Äôs work is ending up taking SWI-Prolog to a place too far outside ISO Standard Prolog. I have an antidote for such worries: let‚Äôs help create a new standard around Jan‚Äôs work instead. Let‚Äôs add some good stuff to an already wonderful programming language. Unfortunately, creating a new standard for full Prolog, in most places just repeating what the ISO standard says, would be a daunting task and isn‚Äôt going to fly. The work on a new standard can only be motivated by a need to focus on a particular area, such as the Web.</p>
<h3 id="librarypengines">library(pengines)</h3>
<p>The latest library addition relevant to Web development is <code>library(pengines)</code>. A pengine (short for Prolog engine) is modelled on the interactive toplevel of standard Prolog. This top level has a special status: it is lazy because new solutions are calculated upon user request, but it is inaccessible to programs, i.e. a program cannot <em>internally</em> set up a query and request solutions lazily. A pengine is like an interactive Prolog toplevel which is accessible to Prolog as well as to other programming languages. Queries and commands are given as textinput in response to prompts.</p>
<p>The design behind pengines is inspired by the protocol we as programmers adhere to when we invoke a Prolog shell from our OS prompt, load a program, pose a query, are presented with a solution (or a failure or an error), type a semi-colon in order to ask for more, or hit return to stop. There are only a few ‚Äúconversational moves‚Äù you can make in each state, and the possibilities can easily be described, by a state machine for example, as we have done for Pengines.</p>
<p>A pengine is a thread on a (often remote) Prolog pengine server.</p>
<ul>
<li>The query language is Prolog, i.e., the client uploads a short Prolog program to the pengine that provides the data exchange needed by the client based on the clean relational interface of the deductive Prolog database.</li>
<li>Subsequently, the client sends one or more Prolog queries with result templates to the pengine.</li>
<li>The pengine answers with a set of answer tuples based on answer bindings of a template. Data representation is standardized. At the moment we have two formats: Prolog syntax for Prolog clients and a standard representation of Prolog terms in JSON for e.g., JavaScript clients.</li>
<li>Pagination is based on Prolog backtracking. As an option, results can be batched in chunks of a certain size, e.g., return (max) 20 results per communication.</li>
</ul>
<p>A pengine is bound to a module. This module imports from the pengine‚Äôs application module. The module is totally private to the Pengine that created it and the Pengine cannot perform any actions outside this module, except what is provided by APIs given to it (i.e., imported in the Pengine‚Äôs application module and safe, either inferred or declared). So, a Pengine‚Äôs application may provide an API <code>assert_ancestor/2</code>, which asserts the new knowledge in the global dynamic database but cannot do that directly.</p>
<p>Pengines are not suitable for apps that do server push.</p>
<pre><code>&lt;html lang="en"&gt;   
    &lt;head&gt;
        &lt;script src="/vendor/jquery/jquery-2.0.3.min.js"&gt;&lt;/script&gt;
        &lt;script src="/pengine/pengines.js"&gt;&lt;/script&gt;
        &lt;script type="text/x-prolog"&gt;
        
    	   q(X) :- p(X).
           
		   p(a). p(b). p(c). p(d). p(e). p(f). p(g).

        &lt;/script&gt;
        &lt;script&gt;
            var pengine = new Pengine({
                ask: 'q(X)',
                template: 'X',      // explicit template
                chunk: 3,           // chunks of three answers
                onsuccess: handleSuccess
            });
            function handleSuccess() {
                $('#out').html(this.data);
                if (!this.more) {
                   $('#next').prop("disabled", true);
                }
            }
        &lt;/script&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;div id="out"&gt;&lt;/div&gt;
        &lt;button id="next" onclick="pengine.next()"&gt;Next&lt;/button&gt;
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>To play with this particular example, please follow this link:</p>
<p><a href="http://pengines.swi-prolog.org/apps/scratchpad/index.html#6b1cba0c-8702-11e5-b081-00163e8fc784.html">http://pengines.swi-prolog.org/apps/scratchpad/index.html#6b1cba0c-8702-11e5-b081-00163e8fc784.html</a></p>
<h3 id="swish">SWISH</h3>
<p><a href="http://swish.swi-prolog.org">SWISH</a>  (‚ÄúSWI-Prolog for SHaring‚Äù)  was the first application built on the technology that was later to become Pengines. Since then, SWISH has improved greatly due to the work of Jan. Here are some links to more applications of SWISH. The reader is invited to try them out:</p>
<ul>
<li><a href="http://linkedpolitics.d2s.labs.vu.nl/swish">SWISH (in Cliopatria) for Semantic Web applications</a></li>
<li><a href="http://cplint.lamping.unife.it">SWISH for Probabilistic logic programming</a></li>
<li><a href="http://lpn.swi-prolog.org">SWISH for Prolog tutorials</a></li>
</ul>
<p>SWISH is becoming a viable choice of IDE also for serious Prolog development. Jan has added a lot of user interface features, such as rendering of terms as tables, trees and charts, literal programming in the form of Prolog Notebooks, and has plans for adding more. Collaborative  programming, for example, is clearly within reach. Expanding and refining its capabilities even further is a given in a roadmap for SWI-Prolog. The SWISH application is also a nice demonstration of how much of Prolog can be exposed through a GUI built on modern Web technologies.</p>
<p><img src="https://i.imgur.com/HWWzhgV.png" alt="enter image description here"></p>
<p>So what is the relation of SWISH to Pengines? Behind what is referred to as a <em>runner</em> in SWISH hides in fact a pengine. A click on the Run button creates a pengine on the server running the query entered in the query pane, after having first consulted the source code in the editor located to the left. The runner can be seen as both a representation of the <em>state</em> of the pengine, and when it needs to <em>present</em> something, it does so on the runner.</p>
<p>Subject to a server setting, you are able to run at most three pengines concurrently, each represented by its own runner. They are not capable of communicating though. (In practice they could, via the JavaScript process.)</p>
<h3 id="other-apps">Other apps</h3>
<p>In this section I briefly mention two other application, much simpler than SWISH.</p>
<ul>
<li>
<p><a href="http://pengines.flov.gu.se:3031/apps/scratchpad/index.html">Scratchpad</a><br>
As a way to learn how to program the interaction between JavaScript and Prolog, and for the purpose of quickly prototyping small Pengines applications, Pengines Scratchpad allows you to write an HTML document in an editor and click the Run button in order to render it.</p>
<p>Apart from the usual <code>&lt;style&gt;</code> and <code>&lt;script type="text/javascript"&gt;</code> tags, Pengines Scratchpad also supports a <code>&lt;script type="text/x-prolog"&gt;</code> tag where you can write your Prolog code. You can program against the browser in the same way as you would write your Prolog program in an editor, consult the file, and ask queries in the Prolog REPL. For I/O you must however use <code>pengine_input/2</code> instead of <code>read/1</code> and <code>pengine_output/1</code> instead of <code>write/1</code> in order to read user‚Äôs input and write the output from a program.</p>
</li>
<li>
<p><a href="http://pengines.flov.gu.se:3031/apps/psglab/index.html">PSG Lab</a><br>
PSG Web Laboratory is designed as an aid for students to explore context-free phrase structure grammars for natural language. It helps the student to understand the relationship between grammars, strings and trees, and the notions of syntactic ambiguity and recursion.</p>
</li>
</ul>
<h3 id="the-prolog-web">The Prolog Web</h3>
<p>Note that the Web applications listed in the previous section are all of a certain <em>kind</em>, exercising only an important but relatively small part of what Pengines has to offer, namely the ability to create and control a remote pengine from (e.g.) JavaScript. There‚Äôs no distribution going on, and no concurrency, except of course for the distribution and concurrency involved in any Web application with a back and front end.</p>
<p>Another kind of application, also made possible by Pengines, is what I shall refer to as the <em>Prolog Web</em> ‚Äì Prolog programs distributed over a network of <em>nodes</em> acting as both clients and servers in a <em>peer-to-peer architecture</em>. SWISH, as well as the Pengines platform, already serve as such nodes.</p>
<p>The Prolog Web is characterised by the interlinking of Prolog programs by means of a meta-predicate <code>pengine_rpc/3</code> and a URI singling out what is essentially a Prolog module.</p>
<p>On the Prolog Web, and by means of <code>pengine_rpc/3</code>, a pengine running in a node A can call and try to solve a query in the context of another node B, taking advantage of the data being offered by B, just as if the data was local to A.</p>
<p>A client Prolog process can query a node by calling <code>pengines_rpc/2</code> with the first argument a URI pointing to the node, and the second argument a goal that we want to run with the Prolog program held by the node. Another notation that will be used in the present paper (mostly for the purpose of saving space) is <code>Goal @ URL</code>.</p>
<p>Consider the following example, given in the form of a diagram:<br>
[Make the upper boxes dotted and change also the lower boxes]</p>
<p><img src="https://i.imgur.com/VicEABn.png" alt="enter image description here"></p>
<p>A client asks the node <code>http://ex1.org</code> for solutions to the query <code>r(X, Y)</code>. Solutions appear, one by one, in exactly the same lazy manner as if the client was asking a local program formed by the union of the programs stored by the three nodes.</p>
<p>Underlying the process of finding the solutions to <code>r(X, Y)</code> is a ‚Äúconversation‚Äù among the client and the pengines running on the three nodes  <code>http://ex1.org</code>,  <code>http://ex2.org</code> and  <code>http://ex3.org</code>. Three pengine processes are created (in the order left to right with respect to the diagram), one on each server. They remain alive as long as the query is running, but terminate (in the order right to left) after having written the last answer to the client terminal and then prompting for another query. Note that at a given point in time, only one of the three pengines involved is actually working, while the others are waiting for something to do. Indeed, when <code>pengine_rpc/3</code> is used, communication between pengines is synchronous by design, and no real parallelism is going on.</p>
<p>In my view, this approach to distributed logic programming is very simple and easy to understand, in part because it works so similar to modules. <code>pengine_rpc/2</code> is furthermore a predicate that is <em>pure</em>, at least as long as predicate that gets called in the first argument is pure. Indeed, people into purity should feel comforted by the fact that the following seems to hold:</p>
<p><strong>Pure Web Prolog = Pure Prolog + pengine_rpc/2</strong></p>
<p>Of course, there are a few extra problems that show up, having to do with the nature of the Web (or more generally with the nature of distributed programming) rather than something to do with semantics. Dealing with latency, network outages, crashing servers, etc. ‚Äì this happens frequently on the Web and there is not much one can do about it besides throwing an error and possibly fall back on a different route.</p>
<p>Some of the backtracking involved in the search for solutions is taking place over the network, and network roundtrips take time ‚Äì a lot of time in comparison with other computational steps that programs typically perform. Since running a distributed program may involve very many roundtrips during backtracking, the times may add up to a significant slowdown compared to running a centralised program. By relying on the <code>chunk</code> option supported by <code>pengine_rpc/3</code> it is possible to avoid some of these roundtrips. I won‚Äôt go into details about this here, but see (Lager and Wielemaker 2013).</p>
<h4 id="how-about-some-hands-on-experience">How about some hands-on experience?</h4>
<p>Note that <code>pengine_rpc/2</code> is accessible also in SWISH. This demonstrates very nicely that an instance of SWISH can be used as a human user interface to the Prolog Web. Selecting the following link takes you to an example where one instance of SWISH is asking an instance of a ClioPatria server (serving also as a pengines node) hosting almost 24 million RDF triples some queries that have been prepared for you:</p>
<p><a href="http://swish.swi-prolog.org/p/Demo%20of%20pengines_rpc/2.pl">http://swish.swi-prolog.org/p/Demo%20of%20pengines_rpc/2.pl</a>.</p>
<p>An example that shows how slow it can be?</p>
<p>Everything that can be done in SWISH can also be done at the Prolog prompt in a shell. The reader is invited to play with <code>pengines_rpc/2</code> by starting up SWI-Prolog in a terminal on a local machine, load <code>library(pengines)</code>, and use <code>pengines_rpc/2</code> to query the same ClioPatria server as above:</p>
<pre><code>?- use_module(library(pengines)).
true.

?- pengine_rpc('http://linkedpolitics.d2s.labs.vu.nl', rdf(S, rdf:type, lpv:'EUParty')).
S = 'http://purl.org/linkedpolitics/EUParty/ARC' ;
S = 'http://purl.org/linkedpolitics/EUParty/EDD' ;
S = 'http://purl.org/linkedpolitics/EUParty/ITS' ;
...
</code></pre>
<p>Should the reader want even more hands-on experience I recommend a visit to the Genealogist tutorial at:</p>
<p><a href="http://www.swi-prolog.org/pengines/Genealogist.html">http://www.swi-prolog.org/pengines/Genealogist.html</a></p>
<p>The purpose of this tutorial is to show how to implement both Web services (Web API<img draggable="false" class="emoji" alt="üòí" src="https://twemoji.maxcdn.com/36x36/1f612.png">) and graphical user interfaces. You need to download and install the Pengines platform in order to use it.</p>
<h4 id="logic-web">Logic Web</h4>
<p>Each of the three programs in our example, as well as the union of them all, has a logical interpretation. This means that what we do in fact have here is not only a Prolog Web, but also a <em>Logic Web</em>. Since each of these may have a different owner and/or maintainer, and since what we have here is a decentralised system, we are also approaching something resembling a kind of <em>Semantic Web</em>, a vision of the Semantic Web first proposed in May 2001 in an article by Tim Berners-Lee, James Hendler and Ora Lassila published by Scientific American as</p>
<blockquote>
<p>an extension of the current one, in which information is given well-defined meaning, better enabling computers and people to work in cooperation.</p>
</blockquote>
<p>They furthermore have this to say:</p>
<blockquote>
<p>For the semantic web to function, computers must have access to structured collections of information and sets of inference rules that they can use to conduct automated reasoning.</p>
</blockquote>
<blockquote>
<p>Adding logic to the Web ‚Äì the means to use rules to make inferences, choose courses of action and answer questions ‚Äì is the task before the Semantic Web community at the moment.</p>
</blockquote>
<p>Backed up by W3C recommendations such as RDF, SPARQL and OWL there has been a lot of activity in the Semantic Web field in the years following the publication of the article. The Semantic Web is based on logic and enables so called ‚Äúsemantic reasoners‚Äù to draw conclusions based on facts represented by RDF triples. The idea as such is sound and very powerful, but the W3C recommendations are complex, and it is often difficult to see how they fit together and how to make use of them when building practical applications. (This may be my subjective perception.)</p>
<p>We are not in any way <em>against</em> the Semantic Web, but rather want the Prolog Web to be a part of it, yet remain simpler.</p>
<p><img src="https://i.imgur.com/ve97pj6.png" alt="enter image description here"></p>
<ul>
<li>Semantic Web Knowledge Representation Languages (such as RDF, RDFS and OWL)</li>
<li>Semantic Web Query Languages (such as SPARQL)</li>
<li>Semantic Web Services</li>
<li>Semantic Web Discovery Services</li>
<li>Semantic Web Agents</li>
<li>Semantic Web Wikis</li>
<li>Semantic Web User Interfaces</li>
<li>Semantic Web Programming Languages</li>
</ul>
<p>The fact that Horn clause logic is part of what makes Prolog into Prolog clearly implies the existence of a <em>Logic Web</em>, or a <em>Web of Horn Clause Logic</em> to be more precise. Note however that the Web of Logic is not only ‚Äúsmaller‚Äù than the Web of Prolog, but also more abstract. After all, Horn clause logic is the abstract, formal, logical underpinning of Prolog.</p>
<p>It seems that what we have here is a simple way to freely distribute knowledge bases in the form of logic programs over a network of computers, while still adhering to the formal semantics of the language. With a large number of nodes running Web Prolog programs that interlink to other Web Prolog programs, we have created a logic programming (and logic <em>programmable</em>) layer on top of the conventional Web, a layer that in principle can grow as big as we want it to.</p>
<blockquote>
<p>If you stripped out function symbols, you can‚Äôt construct answers or intermediates of unrestricted size; you can only use atoms which appear in the program and the query. As a result, the set of all possible solutions to any query is finite, so taking the least fixed point of the program/query will always terminate. Datalog (a relational database query language based on Prolog) works on this principle.</p>
</blockquote>
<p>It means that what we have here is a layer on top of the Web with a model theoretic semantics. Negation as failure adds a non-monotonic operator. Does it follow that we <em>know</em> the meaning of a the program that we are working with? Not necessarily, we may not have access to the code, and for this reason alone we may not trust it.</p>
<p>One way to increase trust in a resource is to offer a way to inspect the code, e.g. through a listing facility.</p>
<p>As another way to increase the trust in a Web Prolog code resource, we can generate an explanation in the form of a <em>proof tree</em>. Here I will point to a way to generate a proof tree for a query that uses rules that may call <code>pengine_rpc/3</code>. The idea is to use a proof constructing meta-interpreter that injects <em>itself</em> in the pengine running the call to <code>pengine_rpc/3</code>. (Look carefully at the second clause of <code>prove/2</code> below.) With this program it is possible to generate a proof tree for any query (involving the subset of Prolog that the meta-interpreter can handle), even those that need another pengine node to be answered (and which in turn may need yet another pengine node, and so on).</p>
<pre><code>prove(true, json{label:true}) :- !.
prove(pengine_rpc(URL, Bs, Opts), Proof) :- !,
    pengine_rpc(URL, prove(Bs, Proof0), [
        src_predicates([prove/2, prove_body/2])
        | Opts
    ]),
    atomic_list_concat([Proof0.label, URL], '@', Node),
    Proof = json{label:Node, children:Proof0.children}.
prove(H, Proof) :-
    clause(H, Bs),
    prove_body(Bs, BSProof),
    term_to_atom(H, HA),
    Proof = json{label:HA, children:BSProof}.

prove_body((B, Bs), [BT|BTs]) :- !,
    prove(B, BT),
    prove_body(Bs, BTs).
prove_body(B, [BT]) :-
    prove(B, BT).
</code></pre>
<p>To see a run of an (admittedly very silly) example, please visit the following program:</p>
<p><a href="http://pengines.swi-prolog.org/apps/scratchpad/index.html#1c12c372-8714-11e5-be28-00163e8fc784.html">http://pengines.swi-prolog.org/apps/scratchpad/index.html#1c12c372-8714-11e5-be28-00163e8fc784.html</a></p>
<p>Note the use of the <code>pengine_rpc/3</code> option <code>src_predicates(List)</code>. It sends the local predicates denoted by <code>List</code> to the remote pengine, where <code>List</code> is a list of predicate indicators. Note also the use of dicts for building the proof tree, and the consistent use of <code>json</code> for dict tags. This ensures that the proof tree will reach the client in the form of JSON, where it can be rendered as a tree.</p>
<p>The above meta-interpreter is likely to blow up for realistic scenarios involving very large proof trees. But that‚Äôs not really the point since the suggestion is not to make <code>prove/2</code> a kind of Pengines builtin. The approach as such is very flexible since it is the programmer who decides what kind of proofs that should be built and how, and it‚Äôs the programmer‚Äôs responsibility to write a version of a proof collector that works for a given scenario. In practice we probably don‚Äôt want to show the proof at the clause level, but it can be interesting for showing distribution of a query over multiple servers.</p>
<h4 id="logic-web-user-interfaces">Logic Web user interfaces</h4>
<p>Clients such as Web browsers can through a convenient JavaScript API be used as human interfaces to the Logic Web. As I shall dig deeper into later, this could be not only GUIs, but VUIs (Voice User Interfaces) as well, or even multimodal user interfaces.</p>
<h4 id="a-word-about-restfulness">A word about RESTfulness</h4>
<p>A RESTful web API that supports the a-tuple-at-a-time retrieval of solutions to a query typical of Prolog and in that solutions are given in the form of Prolog variable bindings, encoded as JSON.</p>
<p>Non-statefulness</p>
<p>We choose to work with a <em>virtual index</em> to the solutions that a query has, without actually generating the solutions. Each solution in the sequence of n solutions to a query receives an integer index in the range 1‚Ä¶n. This makes a query for the ith solution of a goal functional and deterministic.</p>
<p>Presenting this as a RESTful API is of course trivial.</p>
<p>GET /solution?query=q&amp;i=i Retrieve the ith solution to the query q</p>
<p>URIs can now be seen as declarative expressions rather than commands, and each solution to a query has become a resource (in REST parlance), with the consequence that it is uniquely addressable by a URI, which in turn means that it may for example be bookmarked (using the bookmarking mechanism available in browsers.</p>
<p>The Prolog state plays the role of a kind of <em>cache</em>, and the act of resetting the Prolog state is equivalent to the act of <em>flushing</em> this cache. The comparison to a cache seems natural also in light of the fact that all that is does is to (under certain conditions) increase the efficiency of the server. In particular, it does not change the semantics of the API.</p>
<p>To take care of the problem of server threads ‚Äújust hanging there‚Äù indefinitely, wasting valuable resources, we allow the cache to expire after a set number of seconds without activity (again by killing the thread in which the query is running). For example, if the set number of second is 60, then for the case of</p>
<p>GET /solution?query=rdf(S,p,O)&amp;i=1<br>
‚Ä¶ 61 seconds passing‚Ä¶<br>
GET /solution?query=rdf(S,p,O)&amp;i=2</p>
<p>the Prolog state would not be preserved in between the requests. Note that the semantics is preserved though.</p>
<h4 id="pengines-are-agents">Pengines are agents</h4>
<p>The Logic Web is supported (and in a sense ‚Äúimplemented‚Äù) by the <em>Web of Logic Agents</em>, a kind of agents on speaking terms with each other. (The expression ‚Äúspeaking terms‚Äù is actually very fitting, since, as we shall see, the language that they use in order to communicate are Prolog terms.)</p>
<p>Two key discriminators for agents are that an agent has its own thread of control and that it is capable of communicating with other agents in order to get things done. Thus, it makes sense to regard a pengine as a very simple web-based agent, even when all it does is to deduce facts from Horn clause theories and communicate the results of doing so to other agents, pengines as well as humans.</p>
<p>There are a couple of advantages with the notion of Web-based agents: 1) no firewalls ‚Äì the ports are open, 2) the browser is capable of acting as a very powerful multimodal user interface. We shall have more to say about multimodal user interface further down.</p>
<p>So underlying the Logic Web we have a ‚ÄúAgent Web‚Äù. The difference between the level of the Logic Web and the level of the ‚ÄúAgent Web‚Äù is one of abstraction. When working on the level of the Logic Web, the communication between the agents is not visible and we don‚Äôt need to care about it if we don‚Äôt want to ‚Äì it has been abstracted away.</p>
<p>If you really want to know, this is how it looks like:</p>
<pre><code class="prism language-prolog">:- use_module(library(pengines)).

?- pengine_create([server('http://linkedpolitics.d2s.labs.vu.nl'),ask(rdf(S, rdf:type, lpv:'EUParty'))]).
true.

?- pengine_event(E, []).
E = create('24c7ad82-3089-4186-8de4-175127697e1b', [slave_limit(3), answer(success('24c7ad82-3089-4186-8de4-175127697e1b', [rdf('http://purl.org/linkedpolitics/EUParty/ARC', rdf:type, lpv:'EUParty')], 0.000132939, true))]).

?- pengine_next('24c7ad82-3089-4186-8de4-175127697e1b', []).
true.

?- pengine_event(E, []).
E = success('24c7ad82-3089-4186-8de4-175127697e1b', [rdf('http://purl.org/linkedpolitics/EUParty/EDD', rdf:type, lpv:'EUParty')], 0.00011355899999999919, true).

?- 
</code></pre>
<p>Pure and monotonic Prolog programs have known advantages compared to impure or non-monotonic ones, and staying with monotonic programs is therefore beneficial. Unfortunately, monotonicity also limits applicability considerably, since the only way to obtain the results of a computation from such programs are the answer substitutions provided by the Prolog toplevel. Most ways of performing I/O takes us outside this realm.</p>
<p>Prolog is only partly a logic programming langage. It can handle also the procedural aspects of programming and the interaction with users. This is what makes Prolog a <em>general</em> programming language. So far, our Logic Web examples have been completely declarative and purely logical. However, pengine nodes are also capable of running Prolog programs that are inherently procedural, written in full Prolog, including parts of the extralogical subset, but excluding operations that might compromise the server.</p>
<p>Full Prolog extends pure Prolog with:</p>
<ul>
<li>the pruning operation cut</li>
<li>side effects such as input and output operations on files and operations on the internal database</li>
<li>metalogical operations such as <code>var/1</code></li>
<li></li>
</ul>
<p>I/O in particular is necessary for interaction more complex than the answer substitutions provided by the Prolog toplevel ‚Äì making queries, requesting next solution, etc. As can be seen from the following example, pengines can handle I/O:</p>
<pre><code>&lt;html lang="en"&gt;   
    &lt;head&gt;
        &lt;script src="/vendor/jquery/jquery-2.0.3.min.js"&gt;&lt;/script&gt;
        &lt;script src="/pengine/pengines.js"&gt;&lt;/script&gt;
        &lt;script type="text/x-prolog"&gt;
    	   
           echo :-
               pengine_input('Please enter a term to echo.', X),
               (   X == null
               -&gt;  true
               ;   pengine_output(X),
                   echo
               ).
                
        &lt;/script&gt;
        &lt;script&gt;
		   var pengine = new Pengine({
               ask: 'echo',
               onprompt: handlePrompt,
               onoutput: handleOutput,
               onerror: handleOutput
           });
           function handlePrompt() {
               pengine.respond(prompt(this.data));
		   }
           function handleOutput() {
               $('#out').append(this.data + "&lt;br/&gt;");
		   }
        &lt;/script&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;div id="out"&gt;&lt;/div&gt;
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>You may want to try this yourself ‚Äì just click the following link if you do:</p>
<p><a href="http://pengines.swi-prolog.org/apps/scratchpad/index.html#2c49fbb6-8c64-11e5-9b67-00163e8fc784.html">http://pengines.swi-prolog.org/apps/scratchpad/index.html#2c49fbb6-8c64-11e5-9b67-00163e8fc784.html</a></p>
<p>Another example is:</p>
<p><a href="http://swish.swi-prolog.org/example/io.pl">http://swish.swi-prolog.org/example/io.pl</a></p>
<ul>
<li>pengine_input och pengine_output and pengine_respond</li>
<li>Generalisation of read and write I/O. ??</li>
<li>Multi-party conversations</li>
<li>Concurrency</li>
<li>Prolog mash-up</li>
<li>Prolog Cloud</li>
</ul>
<h4 id="a-thought-experiment">A thought experiment</h4>
<p>Let us perform a thought experiment. Imagine that the Web started out, not as a Web of Documents (Web 1.0), but as a Web of Data comprised of linked Datalog theories. Let us also assume that each predicate and individual constant was somehow given a meaning that was universally agreed upon. In a sense, the Web would then have ‚Äúsprung into existence‚Äù as a Web that was Semantic. Then, by introducing compound terms we would have had something that is Turing complete so that we can do real programming. With compound terms we can also introduce structured documents into the picture, thus build the Web of Documents. With cuts we can prune our search trees so that our programs run faster. With I/O we can build agents that can hold conversations in accordance with communication protocols more varied and interesting than the one between a Prolog system and its user. We end up with a Conversational Web (Web 2.0 ‚Äì a Social Web).</p>
<p>Note that by design, the Semantic Web technologies do not involve compound terms nor I/O, so our thought experiment doesn‚Äôt really work for those technologies.</p>
<h2 id="problems-with-pengines">Problems with Pengines</h2>
<p>Pengines are conceptually quite nice, but there are at least X major kinds of problems with the present version of Pengines. One has to do with architectural limitations when using pengines for concurrent programming, the other has to do with communication among pengines.</p>
<p>Pengines are conceptually really nice. The disadvantage is that the initiative comes from the client, although pengine I/O can be used to turn this around during the lifetime of a pengine.  The overhead is also higher than using plain sockets due to the HTTP overhead and the communication to the pengine.</p>
<p>When a process P<sub>1</sub> takes the initiative and creates a pengine P<sub>2</sub>, P<sub>1</sub> becomes the <em>master</em> of P<sub>2</sub>, and P<sub>2</sub> the <em>slave</em> of P<sub>1</sub>. For some applications on the Web a master/slave architecture is a good idea, but Pengines is, in my view, currently <em>too</em> tied to a master/slave architecture, resulting in a number of restrictions that makes Pengines less expressive than it needs to be.</p>
<p>As a concequence of the master/slave architecture hardwired into <code>library(pengines)</code>, pengines are linked to other processes in the sense that if the master process that created a slave pengine terminates, the slave pengine will terminate too. This makes a lot of sense on the Web of course, in particular for applications such as SWISH, Scratchpad and the Prolog Web. You don‚Äôt want a lot of zombie pengines hanging around that are not connected to any other pengine or process, and in particular, you don‚Äôt want this if the pengine was created from a browser page that has since long been left. But for other kinds of applications you may want to have unlinked pengines that do just that: hang around waiting for input from anyone who knows their PIDs and who can therefore communicate with them.</p>
<p>As Pengines is currently designed and implemented, there are three I/O predicates: <code>pengine_input/2</code>, <code>pengine_respond/2</code> and <code>pengine_output/1</code>. Calling <code>pengine_input/2</code> from inside a pengine sends a prompt to its master process (the process that created the pengine ‚Äì could be JavaScript, could be Prolog, could be another pengine) waits there and expects the master to use <code>pengine_respond/2</code> to input a term. There is currently no way for a running pengine to receive input from its master process without first prompting for it. Also, there is currently no way for <em>any</em> process other than the pengine‚Äôs master process to send input to it.</p>
<blockquote>
<p>You can ask a pengine server to create a pengine. This pengine is only known to you. And you can create multiple slaves, but they only talk to you, not to each other. They also go to a well defined set of states, and are not prepared to accept arbitrary commands in arbitrary states. So, you can create and control a tree of master/slaves, where you are the root. Bu, this is a pure tree.</p>
</blockquote>
<p>The implementation of <code>pengine_input/2</code> uses the built-in <code>thread_get_message/3</code> more or less <em>as is</em> to wait for a response from the master process. Because of the way <code>thread_get_message/3</code> works, this isn‚Äôt flexible enough. Here‚Äôs how the variant with only one argument (which listens to the queue belonging to the thread in which it runs) is documented:</p>
<pre><code>thread_get_message(?Term)
   Examines the thread message queue and if necessary
   blocks execution until a term that unifies to Term arrives in
   the queue. After a term from the queue has been unified
   to Term, the term is deleted from the queue.

   Please note that non-unifying messages remain in the queue. 
</code></pre>
<p>The only way to select and remove a <em>particular</em> term (and this particular term only) from a queue is by unification. <code>thread_get_message/1</code> can be called with the argument (partially) instantiated, or it can be called with an unbound variable. Calling it with an unbound variable will select and remove the term in the front from the queue. Calling it with a partially instantiated pattern (a term) will select and remove the first term that unifies with the pattern. If the queue is empty <code>thread_get_message/1</code> will wait for a term to appear. This works well and is very efficient, but it isn‚Äôt as flexible as it could be.</p>
<p>To see why, suppose that we instead want to 1) match each message against a sequence of patterns that do not necessarily unify with each other, one pattern after another in the order of appearance, and 2) only consider a match that also satisfies certain conditions specified as general Prolog queries. For both 1) and 2), we need to first select and remove a term from the queue, and then, if it doesn‚Äôt match any of the patterns, or if it doesn‚Äôt satisfy the conditions, <em>put it back in again</em>. This is basically what Erlang‚Äôs selective receive is doing, all in a single but very powerful construct, and this is one reason we shall further down be looking much closer at Erlang.</p>
<p>In concurrent programming, processes should be able to react to incoming communication from arbitrary different sources. Pengines only allows this when sources stand in the slave relation to its master.</p>
<p>Concurrent programming in Pengines is too difficult. Sure, one could always claim that concurrent programming is <em>supposed</em> to be hard, but the problem with Pengines is that the difficulties multiply since we are dealing with a language (or a way of programming) that has not been <em>validated</em> as a sound approach to concurrent programming. The very novelty, if it really is novel, becomes an hindrance rather than a help. We would be much better of if we can somehow make it probable that concurrent programming with pengines is a sound idea, and if we can provide design patterns that work. Again, emulating constructs from a programming language such as Erlang, that was designed for concurrent programming and has been validated as such, is probably a better approach.</p>
<h2 id="a-new-language">A new language</h2>
<p>Extremly well-built libraries, and a very interesting framework ‚Äì no mean feat indeed. However, the (probably quite radical) suggestion that this paper wants to make is that it may be time to take the next step up the ladder of abstraction, and to try to come up with a ‚Äúnew thing‚Äù in the form of a new <em>programming language</em> instead. A new programming language may relieve the developer (Jan in particular) of the pressure of having people nagging him to comply with ISO Prolog. It can also draw a lot more attention than a new library or framework, in particular if this new thing can <em>do</em> things on the Web that no other mainstream programming language can do, at least not as easily and naturally.</p>
<p>For a new programming language to succeed it probably isn‚Äôt enough to be simple, expressive and efficient. It also has to be <em>unusual</em> i.e. to offer a different style and a different view of programming. Prolog, already in its traditional form, <em>is</em> unusual in this sense. For example, logical variables is a very useful feature of Prolog that very few other languages can offer and in combination with it automatic backtracking search it is the only mainstream programming language that allows a form of knowledge representation, inference and programming with logic, albeit fairly restrictive.</p>
<p>Another way to succeed might be to offer an unusual way of <em>using</em> the language. What is it for? Systems programming, application programming, scripting, import/export? A Web programming language of the kind we are discussing here is one way to think differently.</p>
<p>Some people have claimed that SWI-Prolog V7 already <em>is</em> a new programming language. Here is a quote from the manual:</p>
<blockquote>
<p>When introducing the extensions in version 7, several people have claimed that SWI-Prolog should choose a new name that does not refer to Prolog, such as Picat or Mercury did. Both languages share concepts with Prolog, but both differ so much that it is practically impossible to run programs unmodified on both a Prolog processor and either Picat or Mercury.</p>
</blockquote>
<blockquote>
<p>This is quite different for SWI-Prolog. Most ‚Äòreasonable‚Äô programs that satisfy the ISO standard or were designed for (especially YAP or SICStus Prolog) run unmodified on SWI-Prolog or can be changed easily to run on multiple systems.</p>
</blockquote>
<p>I have a great deal of respect for standards, but I basically agree with Jan here. Having said that, I think a <em>slight</em> change of names may actually be a good idea. My suggestion is that we call this new language <em>Web Prolog</em> to remind ourselves about the strong link to Prolog and that we use the prefix <em>Web</em> to point to the difference and to highlight our focus on the Web. Let me hasten to add that I don‚Äôt suggest that we should distance ourselves much from Prolog. Web Prolog should be <em>presented</em> as a new language, but most existing Prolog programs would still run without modification.</p>
<p>One of our more ambitious goals should be to get Web Prolog standardised in the W3C. I believe we have a chance at that if we play our cards right. We shall return to the subject of standardisation later in this paper.</p>
<p>It is time to formulate a number of requirements for Web Prolog. What I have in mind here is a Web-aware language, a Web programming language. SWI-Prolog is already a Web-aware language, but all the Web related features are provided in libraries.</p>
<ul>
<li>RDF</li>
<li>SPARQL</li>
<li>JSON</li>
<li>‚Ä¶</li>
</ul>
<p>There is currently, as far as I know, no other programming language as well adapted to the processing of RDF as Prolog.</p>
<p>In the words of (???), this is what can be said about Prolog in comparison with SPARQL:</p>
<blockquote>
<p>Prolog is more versatile than SPARQL, allows composing of the logic from small building blocks and does not suffer from the object-relational impedance mismatch."</p>
</blockquote>
<p>We also want to solve the problems with pengines that were listed above. We now know that we want to use mechanisms that are already known to be effective for concurrent programming. There are a few around, and I cannot claim that I have evaluated all of them, but as I have already hinted at, Erlang seems to fit the bill quite well. Erlang‚Äôs receive construct offers flexibility with respect to the way a particular message is selected from the mailbox, thus creating more degrees of freedom in the order in which messages may appear ‚Äì a relief since in a concurrent environment not many guarantees on ordering can be given. Erlang furthermore offers a great deal of flexibility with respect to the way the graceful termination or crash of a process influences other processes to which it is related. In Erlang, such mechanisms are programmable, not hardwired.</p>
<h2 id="comparing-prolog-and-erlang">Comparing Prolog and Erlang</h2>
<p>Why Erlang? One reason is that Erlang and Prolog are already in many ways similar. Since Erlang evolved from Prolog, most data types map cleanly between the two languages. Atoms are the same in Erlang and Prolog, and the same goes for integers and floating point numbers.</p>
<p>Lists look and behave the same in Prolog and Erlang, and an Erlang tuple <code>{foo, a, 1}</code> corresponds most naturally to a Prolog term <code>foo(a, 1)</code>. However, note that <code>{foo, a, 1}</code> is a term in Prolog too, of the form <code>{}((foo, (a, 1)))</code>.</p>
<p>Prolog variables are assign-once variables, just like Erlang variables, pattern matching is the dominant way to pass values, just like in Erlang, and just like in Erlang, loops are normally implemented by means of recursion.</p>
<p>Some of these similarities are clearly shown in examples like the following:</p>
<pre><table width="100%" height="100%">
<tbody><tr><th>Sequential Erlang</th><th>Sequential Prolog</th></tr>
	<tr><td valign="top">% length/1

length([]) -&gt; 0;
length([_|T]) -&gt; 
    1 + length(T).
</td><td>% length/2

length([], 0).
length([_|T], N) :-
    length(T, N1), 
    N is N1 + 1.
	
</td></tr>
   <tr><td valign="top">% naive reverse
   
reverse([]) -&gt; [];
reverse([H|T]) -&gt; 
    reverse(T) ++ [H].
</td><td>% naive reverse

reverse([], []).
reverse([H|T], R) :-
    reverse(T, RevT),
    append(RevT, [H], R).
	
</td></tr></tbody></table></pre>
<h3 id="erlang----the-missing-parts">Erlang ‚Äì the missing parts</h3>
<p>It is sometimes lamented that the inventors of Erlang should have chosen a more ‚Äútraditional‚Äù syntax. (As we shall see later, the Elixir programming language actually tries to do something about it!) Prologers do of course beg to differ ‚Äì we are fine with the syntax. What we don‚Äôt like has more to do with semantics and the sacrifice of a lot of good things that Prolog has to offer. It can hardly be denied that something was lost in the process of going from Prolog to Erlang: backtracking search, unification (i.e. two-way pattern matching), logic-based knowledge representation, reasoning, meta-programming, user defined operators, a term expansion mechanism, Definite Clause Grammar (DCG), and other things that Prolog has to offer.</p>
<p>In no way should this be seen to imply that I think that the inventors of Erlang made a <em>mistake</em> when they scrapped Prolog in favor of a simple functional language (i.e. Sequential Erlang), <em>despite</em> the fact that the first versions of Erlang were actually implemented in Prolog. Given the circumstances at the time, given the nature of the problems with programming telephone switches that they set out to solve, and perhaps in an attempt to avoid being dragged down by the post fifth generation dismissal of logic programming, they probably made exactly the right choice.</p>
<h3 id="erlang----the-good-parts">Erlang ‚Äì the good parts</h3>
<p>Erlang has very good support for concurrent programming, made possible by constructs such as spawn, send and receive. Compared to Erlang, Prolog‚Äôs <code>thread_*</code> predicates (present not only in SWI-Prolog but in a couple of other Prolog systems as well) appears to be less well integrated into the language. Indeed, even the long and slightly tedious <em>names</em> of the <code>thread_*</code> predicates in Prolog seem to suggest that this is the case. Compare with succinct names such as <code>spawn</code> (instead of <code>thread_create</code>), <code>send</code> or <code>!</code> (instead of <code>thread_send_message</code>), and <code>receive</code> (instead of <code>thread_get_message</code>). One almost get the impression that Prolog wants us to stay away from concurrency and message passing!</p>
<p>Another non-negligible difference between Erlang and Prolog is that spawn, send and receive work also in a distributed setting, something that is not true for the <code>thread_*</code> predicates. In Erlang, I can spawn a process on a node on a remote machine and subsequently communicate with it using send and receive, not so in Prolog. As I have shown however, pengines also work in a distributed setting. This is one of the things that made me spot the similarities between Erlang and Pengines.</p>
<p>There are some ‚Äúreal‚Äù differences as well. Erlang processes are very lightweight, and completely isolated from each other, while this is not the case with Prolog threads. In Prolog, one thread shares resources (e.g. heap memory) with other threads forked by the same OS process. In Erlang, a process shares nothing with other processes, a kind of isolation that is good for fault tolerance.</p>
<p>In Erlang, creating and destroying processes is very fast. SWI-Prolog uses threads provided by the OS, which are heavier, so creating pengines in SWI-Prolog is not as fast as creating processes in Erlang. For many applications the performance is likely to be sufficient though. According to Jan, ‚ÄúSWI-Prolog can create and join about 100,000 threads per second‚Äù. I‚Äôm not sure how this compares with Erlang.</p>
<p>Sending messages between processes is very fast in Erlang. Sending messages between pengines is probably not far behind, except when sending between pengines running on different machines. Here, pengines are currently using HTTP, whereas Erlang is using raw sockets. Using websockets for pengines communication would likely even out the difference.</p>
<p>In Erlang, we can create a very large number of processes on one machine, likely a <em>much</em> larger number than Pengines can handle. I have read somewhere that an Erlang process can fit in less than 1Kb of memory. According to Jan, each pengine uses a minimum of somewhere around 30Kb, which means that we may still have very many on a normal machine, although not as many as in Erlang.</p>
<h3 id="erlang-and-prolog-from--a-bird‚Äôs-eye-view">Erlang and Prolog from  a bird‚Äôs eye view</h3>
<p>In terms of paradigms, and despite the surface similarities, Prolog and Erlang are almost completely orthogonal to each other, something that can be confirmed by the early branching in a programming language taxonomy such as the one presented in the diagram below.</p>
<p><img src="https://i.imgur.com/FBXrpw6.jpg" alt="enter image description here"></p>
<p>The diagram is constructed by Peter van Roy, and (van Roy 2009) is a really interesting paper about it. For a bigger and more readable version of the diagram, see <a href="https://www.info.ucl.ac.be/~pvr/paradigmsDIAGRAMeng108.pdf">here</a></p>
<p>Let me begin by making a few observations:</p>
<p>Prolog is already a multiparadigm programming language since it contains elements of imperative programming in the form of the assert and retract operations.</p>
<p>Joe Armstrong, one of the creators of Erlang, refers to the kind of programming that this makes possible as <em>Concurrency Oriented Programming</em> (COP). There is no reason we could not do COP in Prolog too. If we can pull that off I believe that we are looking at a quite interesting combination of two programming paradigms. Logic Programming (LP) √† la Prolog mixed with COP √† la Erlang mixed with the Web becomes <em>Concurrency Oriented Web Logic Programming</em> (COWLP).</p>
<p>A logical language such as Prolog allows programs to be read as defining predicates, and the execution of a program as finding a proof for a given statement. A process-based language such as Erlang provides notions of processes and message-passing between processes. As shown by Oz, there is no reason why a single language shouldn‚Äôt be able to do both.</p>
<p>A true multiparadigm language is factored: it is possible to program in one paradigm without interference from the other paradigms.</p>
<h3 id="a-sip-of-elixir">A sip of Elixir</h3>
<p>Let us also take a brief look at Elixir, a relatively new language that compiles into the Erlang VM and therefore belongs in the same paradigm.</p>
<p><a href="http://a115.co.uk/publications/erlang-elixir-startups.html">http://a115.co.uk/publications/erlang-elixir-startups.html</a></p>
<blockquote>
<p>One of the most exciting features is the real time capabilities with channels between JavaScript on the client and Elixir on any of the servers in the cluster. Each single visitor to a website can have its own process on the server and its own real time connection. This opens up possibilities that are not present in traditional Web frameworks.</p>
</blockquote>
<p>Note that it is true also for Pengines that each client has its own process on the server and its own real time connection.</p>
<p>My hope is that we can build a library in SWI-Prolog that will allow us to call spawn, send and receive in a distributed setting too. By implementing them on top of the <code>thread_*</code> predicates and websockets, this should be possible.</p>
<h3 id="popularity-contest-erlang-vs-prolog">Popularity contest: Erlang vs Prolog</h3>
<p>Leaving technical things aside for a while, let us now look at the popularity of Erlang and Prolog. People not familar with Erlang may come with the impression that Erlang, just like Prolog, is a marginal programming language, no more popular than Prolog. This is not true.</p>
<p>Comparing the two languages we find that Erlang is more used than Prolog ‚Äì in fact, Prolog is not even counted.</p>
<p><img src="https://i.imgur.com/Ow0GIWG.png" alt="enter image description here"></p>
<p>This might be a better ranking:<br>
<a href="http://www.tiobe.com/index.php/content/paperinfo/tpci/index.html">http://www.tiobe.com/index.php/content/paperinfo/tpci/index.html</a></p>
<p>Use doesn‚Äôt equate love. A better indication of peoples love of a   programming languages is what they have to say about it. A fun way to investigate this is to use a site called GoogleFight. I have prepared a number of links for you. Just click and enjoy the fights.</p>
<ul>
<li><a href="http://www.googlefight.com/index.php?word1=I+love+Prolog&amp;word2=I+hate+Prolog">I love Prolog vs I hate Prolog</a></li>
<li><a href="http://www.googlefight.com/index.php?word1=I+love+Erlang&amp;word2=I+love+Prolog">I love Erlang vs I love Prolog</a></li>
<li><a href="http://www.googlefight.com/index.php?word1=I+love+Erlang&amp;word2=I+hate+Erlang">I love Erlang vs I hate Erlang</a></li>
</ul>
<h2 id="web-prolog">Web Prolog</h2>
<p>Given our focus on the Web, we should think of Web Prolog as a tool for <em>programming the Web</em>, as a <em>Web programming language</em>. But what is really involved when we say that we are ‚Äúprogramming the Web‚Äù? Is that merely a metonymy meaning ‚Äúprogramming a computer which is a part of the Web‚Äù or should we understand it literally?</p>
<p>On the Web, it‚Äôs very common that a server serves a client code to be executed there. In the case of a Web browser client, the code is usually JavaScript. Less common are scenarios where clients in realtime send code to a server to be executed there. If I can program servers that I do not manage nor own, that is, in my view, a big step towards programming the Web. Or if I can supply program code to such a computer that will be mixed-in with code owned, managed and perhaps written by someone I haven‚Äôt even met, and then run, that would also be ‚Äúprogramming the Web‚Äù, and even more so.</p>
<p>Of course, in this situation safety becomes very important. Just as JavaScript doesn‚Äôt allow you to access the file system of the client device, Web Prolog shouldn‚Äôt allow you to access the file system of the server.</p>
<hr>
<p>Web Logic Programming</p>
<p><a href="http://sandbox.pl">sandbox.pl</a></p>
<p>Cloud programming languages.</p>
<p>Purpose: To built web applications in the form of APIs or GUIs, to work with data.</p>
<p>A superset of a subset of ISO Prolog. ISO Prolog doesn‚Äôt define any predicates relating to the Web.</p>
<h3 id="rdf">RDF</h3>
<p>rdf/3 and rdf/4</p>
<p>Instead of SPARQL queries, you use Prolog queries.</p>
<p>Don‚Äôt think of it as RDF ‚Äì think of it as Prolog! I for one care about RDF only as a piece of Prolog.</p>
<h3 id="json">JSON</h3>
<p>JSON plays an important role in Web Prolog, in particular as a way to encode Prolog terms in a way that makes them understandable to non-Prolog processes.</p>
<p>Also, one reason that I am happy with dicts is the nice and direct way they map to JSON. However, it could actually be made nicer. The tags could be gone.</p>
<h3 id="xml">XML</h3>
<h3 id="pengines">Pengines</h3>
<p>The present version of Pengines is a library module. A programmer who wish to make use of <code>library(pengines)</code> must first load the module. With Web Prolog we do instead aim at a programming language with pengine-like capabilities in the core, in some ways borrowing from Pengines, but in other ways both simplifying and going beyond Pengines.</p>
<p>As far as Web Prolog is concerned, you should only look at Pengines and the applications built on top of Pengines as proofs of concepts. It has been implemented and it works pretty well. So since Web Prolog is similar to Pengines in many ways, it should be straightforward to implement Web Prolog in a similar and possibly even better way.</p>
<h3 id="prolog-extended-with-erlang-constructs">Prolog extended with Erlang constructs</h3>
<blockquote>
<p>Erlang is a concurrent programming language with a functional core. By this we mean that the most important property of the language is that it is concurrent and that secondly, the sequential part of the language is a functional programming language.</p>
</blockquote>
<p>Sequential Erlang is basically Erlang with its data types, one-way pattern matching, functions and control structures, but without spawn, send, receive, and other constructs designed for concurrent programming. The idea behind Web Prolog can thus be described as an attempt to ‚Äúplug out‚Äù sequential Erlang from Erlang and ‚Äúplug in‚Äù sequential Prolog instead.</p>
<p>Indeed, judging from the following quote, it seems that ?? agrees that there are no principled reasons why we couldn‚Äôt replace the sequential functional language with a sequential relational language, e.g. a logic programming language such as Prolog.</p>
<blockquote>
<p>The sequential subset of the language expresses what happens from the point it time where a process receives a message to the point in time when it emits a message. From the point of view of an external observer two systems are indistinguishable if they obey the principle of observational equivalence. From this point of view, it does not matter what family of programming language is used to perform sequential computation.</p>
</blockquote>
<p>Alternatively ‚Äì and this will be my choice ‚Äì what I want to do can be described as an attempt to <em>extend</em> Prolog with constructs such as spawn, send and receive. We shall keep everything that Prolog has to offer, and extend it with a (probably performance-wise sub-optimal) version of what makes Erlang such a great language for programming message-based concurrency. The choice between extending Prolog with Erlang-ish constructs and extending Erlang with Prolog-ish constructs is easy to make. We only have to imagine the following Web Prolog program rendered in Erlang instead to understand why this would not work:</p>
<pre><code class="prism language-prolog"> ancestor(X, Y) :- parent(X, Y).
 ancestor(X, Z) :- parent(X, Y), ancestor(Y, Z).

 parent(X, Y) :- father(X, Y).
 parent(X, Y) :- mother(X, Y).

 mother(trude, sally).

 father(tom, sally).
 father(tom, erica).
 father(mike, tom).
</code></pre>
<p>The Erlang syntax ‚Äì ugly to some, beautiful to others ‚Äì would live on in the Erlang-ish environment that is Web Prolog, instead of being taken over by the Ruby-ish syntax of Elixir. It will live on simply because it is hard to imagine Web Prolog without a Prolog-ish syntax. Indeed, I would be utterly surprised if someone suggested a Ruby-ish syntax for Prolog!</p>
<p>The very idea of extending one programming language into another, with concepts taken from another paradigm, is of course not new. C++ extends C with OO concepts and Paulo Moura‚Äôs <a href="http://logtalk.org/">LogTalk</a> does the same for Prolog. There are many others.</p>
<p>Merging two languages doesn‚Äôt always work. In an enjoyable talk, Joe Armstrong compares the idea of merging the two programming languages Erlang and C++ (apparently an idea suggested by his boss) with the idea of merging Lego and Meccano ‚Äì it just won‚Äôt work.<sup class="footnote-ref"><a href="#fn2" id="fnref2">2</a></sup> This may be true when it comes to Erlang and C++, but it may not, as we shall see, be a bad idea when it comes to merging Prolog and Erlang.</p>
<p>When extending Prolog with Erlang constructs, we should of course first of all cater for the needs of Prolog programmers. At the same time, we also need to remember that there are many more Erlang programmers in the world than there are Prolog programmers, and if we do this right, we may be able to entice some of them to try Web Prolog, which for them would be a (probably slow) Erlang without the functional notation, but with backtracking search, unification, logic-based knowledge representation, reasoning, meta-programming, user defined operators, a term expansion mechanism, Definite Clause Grammar (DCG), and all the other goodies.</p>
<hr>
<ul>
<li>Alignment with Erlang ‚Äì design patterns, architectures, ‚Äúbehaviours‚Äù</li>
<li>Allows sending to any process at any time, as long as the sender knows the Pid of the receiving process.</li>
<li>The prospect of a bigger user base</li>
<li>Text books and tutorials already at hand!</li>
</ul>
<h3 id="web-prolog-borrowing-from-erlang">Web Prolog borrowing from Erlang</h3>
<p>Note that the Erlang-ish primitives in Web Prolog add to the procedural side of Prolog. The declarative side remains unaffected.</p>
<h4 id="spawning-sending-and-receiving">Spawning, sending and receiving</h4>
<p><strong><code>spawn(+Goal, -Pid) is det</code><br>
<code>spawn(+URI, +Goal, -Pid) is det</code></strong></p>
<p>The typical use of <code>spawn/2</code> is to call a locally defined Web Prolog procedure that specifies the behaviour of the process thus created, the kind of messages it will listen for, and what kind of messages will be sent to other processes. What the process does in between is private to it. A successful spawn will bind the last variable to a process identifier, a Pid.</p>
<p>In its simplest form, <code>spawn/2</code> can be implemented on top of <code>thread_create/3</code>,  like so:</p>
<pre><code>spawn(Goal, Pid) :- thread_create(Goal, Pid, []).
</code></pre>
<p>The predicate <code>spawn/3</code> works just like <code>spawn/2</code>, except that it creates the process on a remote node, identified by the URI in the first argument.</p>
<p>Each process created has a <em>mailbox</em>. This is where messsages sent to it are queued up in the order that they arrived.</p>
<p><strong><code>send(+Pid, +Message) is det</code><br>
<code>+Pid ! +Message is det</code></strong></p>
<p>Calling <code>send(Pid, Message)</code> (or <code>Pid ! Message</code>) sends a message <code>Message</code> to the mailbox of the process identified as <code>Pid</code>. A message can be any Prolog term.</p>
<p><strong><code>receive(+PCA-rules) is det</code><br>
<code>receive(+PCA-rules, +Options) is det</code></strong></p>
<p>The receive construct looks in the mailbox and retrieves matching messages. It is also known as <em>selective receive</em>, a very flexible and elegant way to process a queue of messages. (I must confess that I fell in love with it at first sight!)</p>
<p>To the right below, a proposal for the Web Prolog syntax of <code>receive/2</code> is given. To the left is the syntax of Erlang‚Äôs receive.</p>
<pre><table width="100%" height="100%">
<tbody><tr><th>Receive in Erlang</th><th>Receive in Prolog</th></tr>
<tr><td>
receive
   Pattern1 [when Condition1] -&gt; 
         Action1;
   Pattern2 [when Condition2] -&gt;
         Action2;
   ...
   PatternN [when ConditionN] -&gt;
         ActionN;
after Delay -&gt;
   Action3
end.

</td><td>
receive({
   Pattern1 [when Condition1] -&gt; 
         Action1;
   Pattern2 [when Condition2] -&gt;
         Action2;
   ...
   PatternN [when ConditionN] -&gt;
         ActionN;
}, [timeout(Delay), 
    on_timeout(Action3)
]).

</td></tr>
</tbody></table>
</pre>
<p>As can be seen we have gotten fairly close to the Erlang notation. The only way to improve on this would probably be to introduce the exact Erlang notation for receive in Web Prolog, something that unfortunately would require us to hack the Prolog parser in order to recognise <code>receive ... after ... end</code>. (And <code>receive ... end</code> since the part <code>after ...</code> is optional.)</p>
<p>In the case of the Prolog construct,  <code>Pattern1, ..., PatterN</code>   are  Prolog  terms,  the  optional <code>Condition1, ..., ConditionN</code> are Prolog goals, and <code>Action1, ..., ActionN</code> are Prolog goals. Note that a call to an action may fail, which in turn causes the call to <code>receive/3</code> to fail, thus causing backtracking. I would like to emphasise that <em>any</em> Prolog goal may serve as a condition or an action, thus placing the burden of avoiding messing things up on the programmer.</p>
<p>Here follows a description of the semantics of <code>receive/2</code> which borrows heavily from the semantics of Erlang‚Äôs receive, as described here:<br>
<a href="http://ndpar.blogspot.se/2010/11/erlang-explained-selective-receive.html">http://ndpar.blogspot.se/2010/11/erlang-explained-selective-receive.html</a> .</p>
<ul>
<li>
<p>When <code>receive/2</code> is called, we start a timer (but only if the timeout option is passed).</p>
</li>
<li>
<p>Take the first message in the mailbox and try to match it against<br>
<code>Pattern1</code>, <code>Pattern2</code>, and so on. If the match succeeds, and if the<br>
<code>Condition</code> succeeds, the message is removed from the mailbox, and<br>
the goal <code>Action</code> following the pattern is called.</p>
</li>
<li>
<p>If none of the patterns in the receive statement matches the first<br>
message in the mailbox, then the first message is removed from the<br>
mailbox and put into a ‚Äúsave queue.‚Äù The second message in the<br>
mailbox is then tried. This procedure is repeated until a matching<br>
message is found or until all the messages in the mailbox have<br>
been examined.</p>
</li>
<li>
<p>If none of the messages in the mailbox matches, then the process<br>
is suspended and will be rescheduled for execution the next time a<br>
new message is put in the mailbox. Note that when a new message<br>
arrives, the messages in the save queue are not rematched; only<br>
the new message is matched.</p>
</li>
<li>
<p>As soon as a message has been matched, then all messages that have<br>
been put into the save queue are reentered into the mailbox in the<br>
order in which they arrived at the process.</p>
</li>
<li>
<p>If the timer elapses when we are waiting for a message, then put<br>
any saved messages back into the mailbox in the order in which<br>
they arrived at the process. If the option <code>on_timeout(OnTimeout)</code><br>
is passed, call the goal <code>OnTimeout</code>.</p>
</li>
</ul>
<p>I have built an tentative implementation of <code>receive/2</code> on top of <code>thread_get_message/3</code>, available at: ‚Ä¶</p>
<pre><code>receive(Rules) :-
   thread_self(Mailbox),
   receive(Mailbox, Rules, [], []).

receive(Rules, Options) :-
   thread_self(Mailbox),
   receive(Mailbox, Rules, Options, []).

receive(Mailbox, Rules, Options, SaveQueue) :-
   (   thread_get_message(Mailbox, Message, Options),
       copy_term(Message, MessageCopy)
   -&gt;  (   select_action(Rules, Message, Action)
       -&gt;  reenter_messages(Mailbox, SaveQueue),
           call(Action)
       ;   receive(Mailbox, Rules, Options, [MessageCopy|SaveQueue])
       )
   ;   reenter_messages(Mailbox, SaveQueue),
       option(on_timeout(Action), Options, true),
       call(Action)
   ).

select_action({}(PatternCond -&gt; Action), Message, Action) :-
   var(PatternCond), !,
   PatternCond = Message.
select_action({}(PatternCond -&gt; Action), Message, Action) :-
   check(PatternCond, Message).
select_action({}(PatternCond -&gt; Action ; _), Message, Action) :- 
   check(PatternCond, Message), !.
select_action({}(_ ; Rules), Message, Action) :-
   select_action({}(Rules), Message, Action).


check(Pattern when Condition, Message) :-
   var(Pattern), !,
   Message = Pattern,
   once(Condition).
check(Pattern when Condition, Message) :- !,
   Message = Pattern,
   once(Condition).
check(Pattern, Pattern).


reenter_messages(Mailbox, SaveQueue) :-
   reverse(SaveQueue, ReversedSaveQueue),
   forall(member(Message, ReversedSaveQueue),
          thread_send_message(Mailbox, Message)). 
</code></pre>
<p>Here are some examples, borrowed from ?? and converted into Web Prolog. The message <code>foo</code> is received ‚Äì then the message <code>bar</code> ‚Äì irrespective of the order in which they were sent:</p>
<pre><code>... 
receive({foo -&gt; true}), 
receive({bar -&gt; true}),
... 
</code></pre>
<p>Process suspends for T seconds:</p>
<pre><code>suspends(T) :- receive({}, [timeout(T)]). 
</code></pre>
<p>Flushes the message buffer:</p>
<pre><code>flushbuf :- receive({ _ -&gt; flushbuf }, [timeout(0)]). 
</code></pre>
<p>Here‚Äôs a priority queue example borrowed from ??. This function will build a list of all messages with those with a priority above 10 coming first:</p>
<pre class=" language-erlang"><code class="prism  language-erlang"><span class="token function">important</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span>
	<span class="token keyword">receive</span>
		<span class="token punctuation">{</span><span class="token variable">Priority</span><span class="token punctuation">,</span> <span class="token variable">Message</span><span class="token punctuation">}</span> <span class="token keyword">when</span> <span class="token variable">Priority</span> <span class="token operator">&gt;</span> <span class="token number">10</span> <span class="token operator">-</span><span class="token operator">&gt;</span>
		<span class="token punctuation">[</span><span class="token variable">Message</span> <span class="token punctuation">|</span> <span class="token function">important</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
	<span class="token keyword">after</span> <span class="token number">0</span> <span class="token operator">-</span><span class="token operator">&gt;</span>
		<span class="token function">normal</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token keyword">end</span><span class="token punctuation">.</span>
 
<span class="token function">normal</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span>
	<span class="token keyword">receive</span>
		<span class="token punctuation">{</span><span class="token variable">_</span><span class="token punctuation">,</span> <span class="token variable">Message</span><span class="token punctuation">}</span> <span class="token operator">-</span><span class="token operator">&gt;</span>
			<span class="token punctuation">[</span><span class="token variable">Message</span> <span class="token punctuation">|</span> <span class="token function">normal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
	<span class="token keyword">after</span> <span class="token number">0</span> <span class="token operator">-</span><span class="token operator">&gt;</span>
		<span class="token punctuation">[</span><span class="token punctuation">]</span>
	<span class="token keyword">end</span><span class="token punctuation">.</span>
</code></pre>
<p>Here is how it can be used in Erlang:</p>
<pre class=" language-erlang"><code class="prism  language-erlang"><span class="token number">1</span><span class="token operator">&gt;</span> <span class="token function">c</span><span class="token punctuation">(</span><span class="token atom">multiproc</span><span class="token punctuation">)</span><span class="token punctuation">.</span>
<span class="token punctuation">{</span><span class="token atom">ok</span><span class="token punctuation">,</span><span class="token atom">multiproc</span><span class="token punctuation">}</span>
<span class="token number">2</span><span class="token operator">&gt;</span> <span class="token function">self</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!</span> <span class="token punctuation">{</span><span class="token number">15</span><span class="token punctuation">,</span> <span class="token atom">high</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token function">self</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!</span> <span class="token punctuation">{</span><span class="token number">7</span><span class="token punctuation">,</span> <span class="token atom">low</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token function">self</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token atom">low</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token function">self</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!</span> <span class="token punctuation">{</span><span class="token number">17</span><span class="token punctuation">,</span> <span class="token atom">high</span><span class="token punctuation">}</span><span class="token punctuation">.</span>      
<span class="token punctuation">{</span><span class="token number">17</span><span class="token punctuation">,</span><span class="token atom">high</span><span class="token punctuation">}</span>
<span class="token number">3</span><span class="token operator">&gt;</span> <span class="token atom">multiproc</span><span class="token punctuation">:</span><span class="token function">important</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>
<span class="token punctuation">[</span><span class="token atom">high</span><span class="token punctuation">,</span><span class="token atom">high</span><span class="token punctuation">,</span><span class="token atom">low</span><span class="token punctuation">,</span><span class="token atom">low</span><span class="token punctuation">]</span>
</code></pre>
<p>Here is the same program in Web Prolog:</p>
<pre><code class="prism language-prolog">important(Messages) :-
    receive({
        Priority-Message when Priority &gt; 10 -&gt;
            Messages = [Message|MoreMessages],
            important(MoreMessages)
    }, [timeout(0),
        on_timeout(normal(Messages))]
    ).

normal(Messages) :-
    receive({
        _-Message -&gt;
            Messages = [Message|MoreMessages],
            normal(MoreMessages)
    }, [timeout(0),
        on_timeout(Messages = [])]
    ).
</code></pre>
<p>It can be used like so:</p>
<pre><code class="prism language-prolog">?- self(S), S ! 15-high, S ! 7-low, S ! 1-low, S ! 17-high.
?- important(Messages).
Messages = [high, high, low, low].
</code></pre>
<p>Erlang allows only a restricted set of operators in <code>when</code> conditions, and completely disallows calling user defined functions. For the use cases the people behind Erlang had, it probably made sense to impose such restrictions.<sup class="footnote-ref"><a href="#fn3" id="fnref3">3</a></sup> I don‚Äôt think we should impose them on Web Prolog though. The ability to carry the values of variables bound by a condition forward to the action part of the rule seems like a very nice thing to have. It makes sense in Web Prolog, it doesn‚Äôt make sense in Erlang.</p>
<p>What can occur in the actions is also unrestricted Web Prolog code. It may be code that is failing, and thus make the <code>receive/2</code> call fail too, or it may be non-deterministic code. As we shall see, allowing both failing and non-deterministic code in actions allows us to build two quite elegant and very useful abstractions: the pengine abstraction and the NDRPC abstraction, the latter on top of the former.</p>
<p>Since the receive construct in Web Prolog is just a normal term, another feature present in Web Prolog but not in Erlang is the ability to compute the PCA-rules on the fly. For example, <code>R1 = (foo -&gt; true), receive({R1})</code> is going to give the same result as <code>receive({foo -&gt; true})</code>.</p>
<p>The nature of Prolog (logic variables and non-determinism) and a (tentative) decision not to impose any restrictions on the Web Prolog receive operation seems to make it into something even more expressive than its Erlang counterpart. As far as I can see, the whole has become bigger and better than the sum of its parts.</p>
<ol>
<li>Allow arbitrary goals in <code>when</code> conditions. (To enforce determinism all goals will be wrapped in <code>once/1</code>. Also, throwing an exception should be equivalent to failure.)</li>
<li>Allow the values of any variables bound by the evaluation of a condition to be carried forward to the corresponding action.</li>
<li>Allow arbitrary goals in actions, failing as well as non-deterministic ones.</li>
<li>Allow PCA-rules to be computed on the fly.</li>
</ol>
<p>Note that this is only an initial suggestion for how to integrate the receive operation into Prolog. There may well exist a prettier syntax, more similar to Erlang‚Äôs, at least if we care to introduce distfix operators into Web Prolog. Semantically, there are also differences, mainly due to the fact that Erlang‚Äôs receive is an <em>expression</em> (with a value given by the expression on the right side of the arrow of a matching rule) rather than a statement (that will succeed or fail as in Prolog, and will not return a value). We could of course introduce a third argument to <code>receive/2</code> for holding a ‚Äúreturn value‚Äù, but that doesn‚Äôt seem necessary nor useful at this point. (If we find that we need it, a better idea might be to hide the return value variable in an option and to either work with a default value or raise an error if the variable isn‚Äôt bound when the receive ‚Äúreturns‚Äù.)</p>
<h4 id="monitoring-and-linking">Monitoring and linking</h4>
<p>Erlang‚Äôs approach to fault tolerance is often described as ‚Äúlet it crash‚Äù. The view taken by Erlang programmers is that you don‚Äôt need to program defensively. If there are any programming errors, the process is automatically terminated, and this is reported to any processes that are monitoring the crashed process. The monitoring process can then restart the process or take other actions.</p>
<p>For this to work, we want to make sure that one process is capable of <em>knowing</em> when another process has crashed (or terminated for some other reason), and I therefore suggest that we add <em>monitors</em> and <em>links</em> in the style of Erlang to Web Prolog. Calling <code>monitor(+Pid, -Ref)</code> creates a new thread dedicated to the observation of the outcome of the computation (success, failure, controlled exit or exception) performed by the process referred to as <code>Pid</code>. It reports the outcome by sending a message to the calling process, then terminates silently. <code>Ref</code> is bound to a reference that will allow <code>demonitor/1</code> to at any time stop monitoring the process. Here is an implementation sketch:</p>
<pre><code>monitor(Pid, Ref) :-
    thread_self(Parent),
    thread_create(wait_to_join(Pid, Parent), Ref, [detached(true)]).

wait_to_join(Pid, Parent) :-
    thread_join(Pid, Status),
    thread_send_message(Parent, Status).

demonitor(Ref) :-
	...
</code></pre>
<p>In Erlang the status messages being sent from the monitored process to the monitoring process are all of the form <code>{down, Ref, Pid, Reason}</code>. For Web Prolog, the exact form of such messages would need to be determined, but I think it would work fine with the following ones.</p>
<pre><code>true
    The goal has been proven successfully.
false
    The goal has failed.
exception(Term)
    The thread has been terminated on an exception. 
exited(Term)
    The thread is terminated on thread_exit/1 using the argument Term.
</code></pre>
<p>Note that the suggested implementation of <code>monitor/2</code> relies on the choice of not letting the calling thread run in a detached mode, since only then a thread can be waited on using <code>thread_join/2</code>. The monitor thread runs in detached mode however, since this allows it to completely disappear once it has done its duty.</p>
<p>Using an extra Prolog thread here seems like a wasteful overkill. Possibly a class of <em>dedicated</em> monitor threads could be introduced and given a low-level C implementation?</p>
<p>See the section about the implementation of <code>pengine_rpc/3</code> for an example of the use of <code>monitor/2</code>.</p>
<p>Erlang has other features that would be nice and perhaps even necessary to have in Web Prolog. For example, Erlang has a <code>link/1</code> function that allows the linking of one process to another, so that (for example) if one process dies, the process linked with it will die too. As we have already remarked, Pengines, as implemented in <code>library(pengines)</code>, are <em>always</em> linked in this way: if the process that created a pengine dies, the pengine will die too. This is not always what we want. For other kinds of applications you may want to have unlinked pengines that do just that: hang around waiting for input from anyone who knows their Pid<img draggable="false" class="emoji" alt="üòí" src="https://twemoji.maxcdn.com/36x36/1f612.png"> and who can use <code>send(Pid, Term)</code> in order to send messages to them. For Web Prolog, we need a more flexible scheme, where the required behavior can be specified programmatically. Therefore, we would like to suggest that we borrow from Erlang here too, and introduce at least the following predicates into Web Prolog:</p>
<ul>
<li>link/1</li>
<li>spawn_link/{2,3}</li>
<li>unlink/1</li>
<li>process_flag(trap_exit, true)</li>
</ul>
<p>Without these, it is probably impossible to build an OTP-like library of behaviors.</p>
<h3 id="web-prolog-and-pengines-v2-use-cases">Web Prolog and Pengines V2 use cases</h3>
<p>Web Prolog focuses on Web-based software systems that</p>
<ul>
<li>need <em>knowledge representation and reasoning</em>, and/or</li>
<li>need <em>data analysis and transformation</em> and/or</li>
<li>are <em>reactive</em> in the sense of the <em>Reactive Manifesto</em> (see <a href="http://www.reactivemanifesto.org">http://www.reactivemanifesto.org</a>).</li>
</ul>
<p>Reactiveness is contributed by the Erlang-ish constructs for spawning processes and handling process communication. The hope is that the logic programming aspects of Web Prolog can be made to co-exist harmoniously with its reactive aspects. Both should be usable in the same program, with processes (e.g. pengines) used for modelling the reactive, deterministic interfaces to the user and other external entities, and with the non-deterministic component behaving as a process, encapsulating the non-determinism.</p>
<p>Erlang‚Äôs contribution here concerns the <em>flow control and the orchestration/choreography of concurrent and possibly distributed processes</em> using message passing.</p>
<blockquote>
<p>[Erlang] provides an architectural infrastructure ‚Äî we can organize our system as a set of communicating processes. By enumerating all the processes in our system, and defining the message passing channels between the processes we can conveniently partition the system into a number of well-defined sub-components which can be independently implemented, and tested. (Armstrong 2003)</p>
</blockquote>
<blockquote>
<p>You see, links are more of an organizational construct. When you design the architecture of your application, you determine which process will do which jobs, and what will depend on what. Some processes will supervise others, some couldn‚Äôt live without a twin process, etc. This structure is usually something fixed, known in advance. Links are useful for that and should not necessarily be used outside of it. (H√©bert 2013)</p>
</blockquote>
<p>The <em>combination</em> of logic-based knowledge representation, reasoning, flow control and the orchestration of concurrent processes is very powerful. Great for building e.g. dialogue systems. Active databases.</p>
<p>Some of the use cases for the Semantic Web are surely also use cases for the Prolog Web. They may not be many, but I would be surprised if they didn‚Äôt exist at all. Databases, expert systems, AI.</p>
<ul>
<li>
<p>Prolog as data querying and transformation tool</p>
</li>
<li>
<p>NoSQL databases. Couchdb built on Erlang, Web Prolog built on Erlang.</p>
</li>
<li>
<p>Holding on to the focus on the Web</p>
</li>
<li>
<p>Most cases for Prolog are covered; exceptions are found where there is a dependency on features lacking from Web Prolog, in particular features that are unsafe.</p>
</li>
<li>
<p>All use cases for Erlang are <em>not</em> covered by Web Prolog. Programming telephone switches is certainly one that isn‚Äôt.</p>
</li>
<li>
<p>SWISH is a use case for pengines. Pengines is a use case for Web Prolog. Ergo, SWISH is a use case for Web Prolog. So is ClioPatria, in the sense that an even more capable ClioPatria could conceiveably be built in Web Prolog.</p>
</li>
<li>
<p>We may want to describe the Prolog Web as a use case for Web Prolog. This does of course beg the question, of what use is the Prolog Web?</p>
</li>
<li>
<p>It may be that the advent of multi-core computers will make Prolog obselete if it doesn‚Äôt move in the direction of somehow make use of it. The high-end Mac Pro comes with 6 cores, and there are mobile phones that have 8 and even 10 cores.</p>
</li>
</ul>
<h4 id="computational-linguistics">Computational linguistics</h4>
<p>Computational linguists would be disappointed if Web Prolog didn‚Äôt provide improvements in their area of application. After all, computational linguistics was one of the initial motivation behind Prolog.</p>
<p>I have selected a couple of things that I think blends in particularly well with the syntax and semantics of Prolog and that would likely find uses outside computational linguistics.</p>
<pre><code>s --&gt; np(Agr), vp(Agr).

np(sg3) --&gt; [uther].

vp(Agr) --&gt; v(Agr).

v(sg3) --&gt; [sleeps].
v(_) --&gt; [sleep].

</code></pre>
<p>In a term-based formalism, the structure of a category is determined by the predicate symbol, the arguments, and the order of the arguments. In a feature-structure based formalism, the structure of a category is defined by its features and their values. The value of a feature may be any element, either atomic or complex.</p>
<p>The following is a so called unification-based grammar for a tiny fragment of English. The variables are supposed to be instantiated to so called <em>feature structures</em>, that in our case would be dicts that are ‚Äúsideways open‚Äù (in a way to be explained). The actual example is borrowed from Stuart Shieber, see <a href="https://dash.harvard.edu/handle/1/11576719">https://dash.harvard.edu/handle/1/11576719</a>:</p>
<p>To make this work, we need a data structure similar to dicts, but but they must be ‚Äúsideways open‚Äù in the sense that Jan describes here:</p>
<blockquote>
<p><strong>Note</strong> In the current implementation, two dicts unify only if they have the same set of keys and the tags and values associated with the keys unify. In future versions, the notion of unification between dicts could be modified such that two dicts unify if their tags and the values associated with common keys unify, turning both dicts into a new dict that has the union of the keys of the two original dicts.</p>
</blockquote>
<p>Json Unification</p>
<p>Assuming that we use sideways open dicts and that <code>===/2</code> is a unification operator for such dicts we can use them when parsing and generating with ordinary DCGs. Consider a grammar where the use of feature structures guarantees number agreement between the subject and the verb of a sentence.</p>
<pre><code>s(S) --&gt; np(NP), vp(VP), {
    S:head === VP:head,
    S:head:subject === NP:head
}.

vp(VP) --&gt; v(V), {
    VP:head === V:head
}.

np(NP) --&gt; [uther], {
    NP:head:agreement:number === singular,
    NP:head:agreement:person === third
}.

v(V) --&gt; [sleeps], {
    V:head:form === finite,
    V:head:subject:agreement:number === singular,
    V:head:subject:agreement:person === third
}.

v(V) --&gt; [sleep], {
    V:head:form === finite,
    V:head:subject:agreement:number === plural
}.
</code></pre>
<p>Here is how the grammar could be used for parsing:</p>
<pre><code>?- phrase(s(S), [uther, sleeps]).
S = fs{head:fs{form:finite,
               subject:fs{agreement:fs{number:singular,
                                       person:third
                                      }
                         }
              }
      }.
      
?- phrase(s(S), [uther, sleep]).
false
</code></pre>
<p>As is usually the case with DCG, and to the detriment of natural language grammar engineers, one needs to avoid left recursive rules such as <code>s --&gt; s, [and] s</code> and <code>np --&gt; np, pp</code> that cause non-termination. In the precence of <em>tabling</em> there would no longer be a reason to do so, and parsing would be an O(n^3) process, which is the best one can hope for.</p>
<p>With this in the language we would certainly have a grammar formalism prettier that DCG and much prettier and more useful than for example W3C‚Äôs <em>Speech Recognition Grammar Specification</em> (SRGS), an XML-based formalism for writing small domain specific grammars that often go under the name of ‚Äúsemantic grammars‚Äù.</p>
<p>I don‚Äôt think people should use this approach for large NLP grammars though. For ‚Äúreal‚Äù NLP grammars one would rather use an adapter to a system such as Grammatical Framework (GF) which comes with grammar resources for more than 35 languages. See <a href="http://www.grammaticalframework.org/">http://www.grammaticalframework.org/</a> for more information.</p>
<p>The next item on my wish list is <em>compositional semantic interpretation</em> in the tradition of Richard Montague.</p>
<pre><code class="prism language-prolog">s(NP@VP) --&gt; np(NP), vp(VP).

np(PN) --&gt; pn(PN).

vp(TV@NP) --&gt; tv(TV), np(NP).

pn(lambda(P,P@sas)) --&gt; [sas].
pn(lambda(P,P@boston)) --&gt; [boston].
pn(lambda(P,P@714)) --&gt; [flight, 714].

tv(lambda(P,lambda(X,P@lambda(Y,serves(X,Y))))) --&gt; [serves].
</code></pre>
<p>Consider the first rule:</p>
<pre><code>s(NP@VP) --&gt; np(NP), vp(VP).
</code></pre>
<p>This rule says that the semantic representation for a sentence consisting of a noun phrase and a verb phrase is obtained by combining the semantic representation for the noun phrase (NP) with the semantic representation for the verb phrase (VP) using the operator ‚Äò@‚Äô, which is our way of representing the application of a lambda term to an argument.</p>
<p>Here is what parsing and semantic interpretation would look like:</p>
<pre><code>?- s(_S,[sas,serves,boston],[]), beta_convert(_S,S).
S = serves(sas,boston).
?-
</code></pre>
<p>One thing that probably led many computational linguists to abandon Prolog was the advent of <em>statistical methods</em> for NLP some fifteen years ago. I know very litte about probabilistic logic programming, but I suppose it could be useful for the purpose of mixing logic and statistical methods. Probabilistic grammars comes to mind.</p>
<p>NLTK</p>
<p>The CLASP project.</p>
<p>TagLog</p>
<h4 id="web-based-multimodal-dialog-systems">Web-based multimodal dialog systems</h4>
<blockquote>
<p><em>Content is king</em>. (Bill Gates, 1996)<br>
<em>Conversation is king. Content is just something to talk about</em>. (Cory Doctorow, 20??)</p>
</blockquote>
<p>I‚Äôm going to start with the area of <em>dialogue systems</em>, simply because this is an area that I myself have worked in. It is easy to get bogged down in details here, and it‚Äôs good to once in a while remind ourselves of our vision, a Prolog Web in the form of a network of Prolog predicates, and a Web capable of talking also to humans. I use the word ‚Äútalking‚Äù here for a specific reason, having to do with my background in spoken dialogue system research. The future Spoken Web, filled with speech enabled applications such as mobile assistants ‚Äì think Apple‚Äôs Siri or Google Now ‚Äì assisting with the communication of the knowledge of the network to humans. Needless to say, they will rely on speech recognition and speech synthesis as well as natural language understanding and generation.</p>
<p>Driven in particular by the Mobile Web, the Spoken Web is almost here. I write ‚Äúalmost‚Äù since not every browser has the speech technologies ready. Google‚Äôs WebSpeech API is implemented by Chrome, and Nuance Communications, a big player in the speech technlogy industry, is able to serve developers with speech recognition and speech synthesis. See <a href="http://nuancemobiledeveloper.com">http://nuancemobiledeveloper.com</a>.</p>
<p>The Spoken Web article</p>
<p>To control the interaction between such components, between the mobile assistant and the Prolog Web, and in particular between the mobile assistant and a human user, a so called <em>dialog manager</em> is needed. The following figure gives a hint of an architecture of a multimodal dialogue system:</p>
<p><img src="https://i.imgur.com/daKqGEm.png" alt="enter image description here"></p>
<p>A central role in the architecture is taken up by the <em>dialogue manager</em>, the component of a dialog system responsible for the state and flow of the conversation, and often the only component that is stateful.</p>
<p>It is often a good idea to run components concurrently and use asynchronous message passing to enable them to communicate. It doesn‚Äôt really matter if components are implemented in Web Prolog or not, since a non-Prolog component can always be proxied by a pengine ‚Äì a kind of adapter between a set-at-a-time cursor-limit based interface and a one-tuple-at-a-time interface if you want.</p>
<p>Use DCG for writing semantic grammars for parsing and understanding as well as for generating natural language. Perform semantic and pragmatic interpretation of the terms representing meaning of utterances against the context of world- and situation knowledge. Use the message passing capabilities provided by <code>send/2</code> and <code>receive/2</code> to implement simple as well as sophisticated dialogue management strategies, such as information-state based strategies or SCXML. I have it from late Scott McGlashan (personal communication) that message passing (event handling) was what made VoiceXML into a workable standard.</p>
<p>Timing is important in dialogue systems.</p>
<p>I would like to convince our NLP colleagues Johan Bos, Patrick Blackburn and Kristina Striegnitz that a ‚Äúfull stack‚Äù dialogue system can be built in a uniform language, taking care of things like parsing, generation, semantic interpretation, dialogue management, knowledge representation and reasoning, and, relying on the availability of JavaScript speech API<img draggable="false" class="emoji" alt="üòí" src="https://twemoji.maxcdn.com/36x36/1f612.png"> in browsers, speech recognition and synthesis.</p>
<p>Interaction part written in JavaScript. Web Prolog for sophisticated interaction., controlled on the server side. Listening, thinking, talking‚Ä¶</p>
<p>‚Äúlinguistic interaction needs intelligence‚Äù</p>
<p>The interaction demands intelligence, the ability to interact appropriately to speech acts given the context in question. Part of the context is obviously so called ‚Äúworld knowledge‚Äù, perhaps in a fairly closed domain, but still, something that we will not be able to store in the client.</p>
<p>Another thing is architecture. Sophisticated conversational agents. Galaxy Communicator. Scxml.</p>
<p>SCXML ‚Äì referera till tyskarnas f√∂rs√∂k att anv√§nda Prolog</p>
<p>Here, we are inspired by Fernandez &amp; Endriss (2007) who build an hierarchy of abstract models for protocols that takes as a starting point protocols based on deterministic finite automata.</p>
<p><img src="https://i.imgur.com/ep4zFMS.png" alt="enter image description here"></p>
<h4 id="graphical-user-interfaces">Graphical user interfaces</h4>
<p>That the interaction offered by spoken dialogue systems is conversational is something that can‚Äôt really be denied. But the same goes for graphical user interfaces in my opinion. They too are conversational. A stance like this can also be found in the user interface/HMI literature. In an interesting paper, Brennan (1990) advocates a pragmatics approach to human-computer interaction. Her view is that:</p>
<blockquote>
<p>[‚Ä¶] thinking of user interfaces in terms of real conversation leads to more specific predictions about how people will behave and to more informative explanations of why interface features succeed or fail. The hope is that employing the conversation metaphor will lead to insights in the kinds of architectures and features that are necessary to support cooperation between people and computers.</p>
</blockquote>
<p>The notion of conversation may seem to stand in some kind of opposition to the notion of direct manipulation. However, as studies of face-to-face communication clearly show, conversation usually involves not only words, but also pointing gestures, nods, eye-to-eye contact, um humns, sign language, etc. Moreover, communication most often takes place in the context of some activity involving non-communicative acts as well. I agree with Brennan when she claims that:</p>
<blockquote>
<p>[‚Ä¶] the dichotomy between direct manipulation and conversation is a false one [‚Ä¶] First, direct manipulation interfaces succeed because they share important features with real conversations. Second, when so called ‚Äúconversational‚Äù interfaces fail, it is because they lack these pragmatic features ‚Äì- that is, words alone do not a conversation make. Third, real conversations actually fulfil many of the criteria for direct manipulation.</p>
</blockquote>
<p>By looking at the interaction between the user and the system as a conversation, we are free to apply maxims of cooperative communication (Grice, 1975; Allwood, 1976), and on such grounds design the most efficient and cooperative dialogue possible.</p>
<p>For example, it seems natural to implement the control of what happens between starting and the quitting an application as a conversation, or perhaps a sequence of conversations.  SWISH is a good example. SWISH is actually a multi agent  dialogue application since a user may interact with (by default) three sessions concurrently, shifting attention from one to another at will.</p>
<h4 id="card-based-user-interfaces">Card-based user interfaces</h4>
<p><a href="https://blog.intercom.io/why-cards-are-the-future-of-the-web/">https://blog.intercom.io/why-cards-are-the-future-of-the-web/</a><br>
<a href="http://ben-evans.com/benedictevans/2013/6/18/canvases">http://ben-evans.com/benedictevans/2013/6/18/canvases</a></p>
<p><img src="https://blog.intercom.io/wp-content/uploads/2014/11/Cards-Future-984.jpg" alt="enter image description here"></p>
<p>An interface built on Bootstrap <em>cards</em>, ideal for the conversation with a mobile device. The idea would be to use cards as the pengine‚Äôs contributions to the dialogue between the user and a running pengine. Not in the same way as SWISH uses its runners though, were each runner ‚Äúcard‚Äù corresponds to a pengine. Instead, each <em>system contribution</em>, of which there may be many in the conversation with a pengine, is given as a card. So <code>pengine_input/2</code> and <code>pengine_output/1</code> have roles to play here.</p>
<p>Card expert system<br>
Card interface to Markus‚Äô tutoring system</p>
<h4 id="robot-programming">Robot programming</h4>
<p>In a series of papers, Di Stefano et al. (?) argue for the use of Erlang for autonomous robot programming.</p>
<blockquote>
<p>[‚Ä¶] it is quite clear that developing software for such kind of robots requires to combine artificial intelligence (AI) concerns, needed to perform perception and adaptation, with motion driving aspects, which are instead typical of control systems. From the same as programming languages point of view, AI aspects for adaptation, like automated reasoning or planning, are usually faced with logic or functional languages, such as Prolog or LISP; on the other hand, motion driving is, in general, a matter of imperative approaches, like C/C++ or assembly, or even Java for low-level/embedded system programming.</p>
</blockquote>
<blockquote>
<p>The Erlang language and the OTP system, thanks to the syntax and programming model, exhibit some characteristics that fit well both of the aspects above: Erlang is functional and somewhat imperative, moreover recent research advances have proved its effectiveness also for AI programming [‚Ä¶], mainly thanks to the ability of handling symbolic/structured data and expressing production rules as function clauses.</p>
</blockquote>
<h4 id="games">Games</h4>
<p>Web-based, playcanvas, Web-based and mobile games is big industry.</p>
<h4 id="home-automation">Home automation</h4>
<p>Web Prolog, with it‚Äôs markedly rule based flavor is, as far as I can see, perfect for home automation. Maybe with one process per device, modeling external devices, sending incoming sensory data from Things as messages to be sent to parts of the system (other processes, some of them pengines) that decides how to react to them. The other way around, ‚Ä¶The Web of Prolog becomes also a <em>Web of Things</em>.</p>
<p>Actually, I have started to replace most of my lamp bulbs at in my department with Philips Hue light bulbs. I plan to build a demo in my home, on top of my private Prolog Web of Things. Philips Hue has a great API.</p>
<p><a href="http://smarthome.geekster.com">http://smarthome.geekster.com</a><br>
<a href="http://coliveira.net/software/why-learning-prolog-can-make-you-a-better-programmer/">http://coliveira.net/software/why-learning-prolog-can-make-you-a-better-programmer/</a><br>
<a href="http://swi-prolog.iai.uni-bonn.narkive.com/E9TpCWOs/prolog-as-a-control-point-of-a-distributed-system-using-corba">http://swi-prolog.iai.uni-bonn.narkive.com/E9TpCWOs/prolog-as-a-control-point-of-a-distributed-system-using-corba</a><br>
<a href="http://kylecordes.com/2010/the-prolog-story">http://kylecordes.com/2010/the-prolog-story</a><br>
<a href="http://www.cs.ru.nl/~peterl/teaching/KeR/assign1-2012.pdf">http://www.cs.ru.nl/~peterl/teaching/KeR/assign1-2012.pdf</a><br>
<a href="http://www.cs.ru.nl/~peterl/teaching/KeR/">http://www.cs.ru.nl/~peterl/teaching/KeR/</a></p>
<p><a href="https://nebrios.com/blog/software-list-iot-automationworkflow-rule-engines">https://nebrios.com/blog/software-list-iot-automationworkflow-rule-engines</a></p>
<p><a href="http://youtu.be/ELq8Vd30_H8">http://youtu.be/ELq8Vd30_H8</a></p>
<h4 id="expert-systems">Expert systems</h4>
<p>There was a time when expert systems was a big thing. One text book concentrates on this (Merrit, 19??), and</p>
<p>Expert systems never really went anywhere, and expert systems in Prolog, using the quite elegant meta-interpreter approach, never really went anywhere either. Speech technology may well give expert systems a push forward, and if so, Web Prolog will be ready for the challenge.</p>
<p>A new boom for expert systems, triggered by among other things speech technology and multimodal technology.</p>
<p>Here‚Äôs a link to a tiny expert system example, just to demo the interaction with a Web browser:</p>
<p><a href="http://pengines.swi-prolog.org/apps/scratchpad/index.html#1c12c372-8714-11e5-be28-00163e8fc784.html">http://pengines.swi-prolog.org/apps/scratchpad/index.html#1c12c372-8714-11e5-be28-00163e8fc784.html</a></p>
<p>ProbLog, CLP, Bayesan networks</p>
<h4 id="digital-humanities">Digital humanities</h4>
<p>Cliopatria</p>
<p>TagLog</p>
<p>There are also the new areas of <em>digital humanities</em> and <em>digital social science</em> that may be able to attract new groups of users.</p>
<h4 id="domain-specific-languages">Domain Specific Languages</h4>
<p>A domain-specific language (DSL) is a programming language (or specification language) of limited expressiveness focused on a particular application domain. Regular expressions and CSS are often used as examples of DSL<img draggable="false" class="emoji" alt="üòí" src="https://twemoji.maxcdn.com/36x36/1f612.png">.</p>
<p>Add distfix operators.</p>
<p>PSG Lab</p>
<h4 id="research-demos">Research demos</h4>
<p>Talks, tutorials and demos</p>
<h3 id="the-idea">The idea</h3>
<ul>
<li>The features inspired by Erlang provide processes and message passing programming.</li>
<li>Message passing programming is exactly what we need to implement a Prolog Web.</li>
<li>Message passing programming is exactly what we need to implement control abstractions for agents, dialogue systems, robots, etc.</li>
</ul>
<h4 id="logic-and-protocols">Logic and Protocols</h4>
<p>Behind all this is a beautiful separation of logic and control Communication protocols are different from APIs in the sense that a protocol may involve not only two dialogue partners but three or more.</p>
<p>Strengthen the procedural side of Prolog, the ability to define protocols.</p>
<h2 id="programming-examples">Programming examples</h2>
<p>Programming examples using Prolog rather than SPARQL. Refer to paper by Wielemaker et al.</p>
<p>This section present a number of programming example. Some of them show that Web Prolog programs can be written in the style of Erlang, whereas others show how to deal with the non-determinism that is not present at all in Erlang.</p>
<p>Note that some examples are very sketchy, in particular the ones towards the end of the section. They have not been tested.</p>
<h3 id="spawning-sending-and-receiving-1">Spawning, sending and receiving</h3>
<p>In Erlang, the <code>spawn</code> family of functions are higher-order functions. In Prolog it is better to refer to <code>spawn/2</code> as a <em>meta-predicate</em>.</p>
<p>Let us start by spawning a very simple function performing a very simple computation that determines the length of the list <code>[a ,b, c]</code>. In Erlang:</p>
<pre class=" language-erlang"><code class="prism  language-erlang"><span class="token number">1</span><span class="token operator">&gt;</span> <span class="token variable">Pid</span> <span class="token operator">=</span> <span class="token function">spawn</span><span class="token punctuation">(</span><span class="token keyword">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token atom">a</span><span class="token punctuation">,</span> <span class="token atom">b</span><span class="token punctuation">,</span> <span class="token atom">c</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">end</span><span class="token punctuation">)</span><span class="token punctuation">.</span>
&lt;<span class="token number">0.34</span><span class="token punctuation">.</span><span class="token number">0</span><span class="token operator">&gt;</span>
</code></pre>
<p>In Web Prolog we spawn a predicate/procedure instead, using a query (goal) rather than a function call:</p>
<pre><code class="prism language-prolog">?- spawn(length([a, b, c], N), Pid).
Pid = 3456.
</code></pre>
<p>Note that with neither the Erlang call nor the Prolog call is a result returned, just a Pid. (In the Prolog call the goal was copied, so the variable <code>N</code> wasn‚Äôt bound.) The result is computed all right, but the spawned process holds on to it and doesn‚Äôt share it with anything or anyone else. In both Erlang and Web Prolog we have to do two things in order to report the result:</p>
<ol>
<li>Instruct the process to send the result back to the calling process (as given by the function <code>self/0</code> and the predicate <code>self/1</code>).</li>
<li>See to it that this result is removed from the message queue of the calling process, and then printed.</li>
</ol>
<p>In Erlang:</p>
<pre class=" language-erlang"><code class="prism  language-erlang"><span class="token number">1</span><span class="token operator">&gt;</span> <span class="token variable">Self</span> <span class="token operator">=</span> <span class="token function">self</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> 
   <span class="token variable">Pid</span> <span class="token operator">=</span> <span class="token function">spawn</span><span class="token punctuation">(</span><span class="token keyword">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token variable">N</span> <span class="token operator">=</span> <span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token atom">a</span><span class="token punctuation">,</span> <span class="token atom">b</span><span class="token punctuation">,</span> <span class="token atom">c</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token variable">Self</span> <span class="token operator">!</span> <span class="token variable">N</span>  <span class="token keyword">end</span><span class="token punctuation">)</span><span class="token punctuation">,</span> 
   <span class="token keyword">receive</span> <span class="token variable">M</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token atom">io</span><span class="token punctuation">:</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token variable">M</span><span class="token punctuation">)</span> <span class="token keyword">end</span><span class="token punctuation">.</span>
3ok
</code></pre>
<p>Also in Erlang, but in the more concise functional style:</p>
<pre class=" language-erlang"><code class="prism  language-erlang"><span class="token number">1</span><span class="token operator">&gt;</span> <span class="token variable">Self</span> <span class="token operator">=</span> <span class="token function">self</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> 
   <span class="token variable">Pid</span> <span class="token operator">=</span> <span class="token function">spawn</span><span class="token punctuation">(</span><span class="token keyword">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token variable">Self</span> <span class="token operator">!</span> <span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token atom">a</span><span class="token punctuation">,</span> <span class="token atom">b</span><span class="token punctuation">,</span> <span class="token atom">c</span><span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token keyword">end</span><span class="token punctuation">)</span><span class="token punctuation">,</span> 
   <span class="token keyword">receive</span> <span class="token variable">M</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token atom">io</span><span class="token punctuation">:</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token variable">M</span><span class="token punctuation">)</span> <span class="token keyword">end</span><span class="token punctuation">.</span>
3ok
</code></pre>
<p>In Web Prolog:</p>
<pre><code class="prism language-prolog">?- self(Self), 
   spawn((length([a, b, c], N), Self ! N), Pid), 
   receive({ M -&gt; writeln(M) }).
3
Self = main,
Pid = 3456, 
M = 3.
</code></pre>
<p>In Erlang, a process is spawned with a function to be executed. This function determines what the process will do when it runs, for example what forms of messages it will listen for, what forms of messages will be passed to other processes, and what it will compute there in between. I may be an simple function that only sends back the result of performing a very simple computation such as computing the lengt of a list. That too is behaviour, just not very interesting. There are much more interesting cases, where for example an Erlang process is used for the orchestration of a bigger network of Erlang processes, i.e. as a controller of other processes (which may in term be controllers of yet other processes). Such functions usually don‚Äôt evaluate to anything that would make us think of functions in the mathematical sense.</p>
<p>A computation server for computing the length of lists is silly too, but it shows the idea.</p>
<pre><code class="prism language-prolog">start :-
   spawn(server, Pid).

server :-
   receive({
       compute(Pid, L) -&gt;
           length(L, N),
           send(Pid, len(N))
   }),
   server.
</code></pre>
<p>This is an example of a <em>stateless</em> server.</p>
<h3 id="stateful-servers">Stateful servers</h3>
<p>The following example, borrowed from Fred H√©bert‚Äôs excellent Erlang book, shows how an agent can be made to hold state and update it during a conversation.</p>
<p>The code creates a process allowing two operations: storing food in the fridge and taking food from the fridge. It should only be possible to take food that has been stored beforehand. With the help of recursion, the state to a process can be held entirely in the parameters of the function/arguments of the predicate. In this case we choose to store all the food as a list, and then look in that list when someone needs to eat something.</p>
<p><img src="https://i.imgur.com/Eu58jL8.png" alt="enter image description here"></p>
<p>In the Prolog version (to the right) I have done my best to emphasise the similarity with Erlang, by using terms such as <code>{From, {store, Food}}</code> and an infix <code>!</code> for sending, just like in Erlang.</p>
<p>The following is a better implementation in Web Prolog:</p>
<pre><code class="prism language-prolog">fridge(FoodList) :-
   receive({
       store(From, Food) -&gt;
           send(From, ok),
           fridge([Food|FoodList]) ;
       take(From, Food) -&gt;
           (   select(Food, FoodList, FoodList1)
           -&gt;  send(From, ok(Food)),
               fridge(FoodList1)
           ;   send(From, not_found),
               fridge(FoodList)
           ) ;
       terminate -&gt;
           true
   }).
</code></pre>
<p>This kind of mutable state you get in Web Prolog is exactly the same you get in Erlang, nothing less, nothing more, which is usually via processes and you need to send messages to change or read from the process state. There are other ways to implement mutable state in Prolog ‚Äì by means of assert and retract for example, or by means of nb_set/2 and nb_get/2. One potentially important advantage of using a process as a mutable state is that it can be made distributed.</p>
<h3 id="current-fridge-is-broken">Current fridge is broken</h3>
<p>As yet another illustration of the shortcomings of the current version of Pengines, we have translated a simple Erlang program into Prolog and made it available in the Scratchpad:</p>
<p><a href="http://pengines.swi-prolog.org/apps/scratchpad/index.html#5fbd7b66-2be0-11e4-a794-00163e937b17.html">http://pengines.swi-prolog.org/apps/scratchpad/index.html#5fbd7b66-2be0-11e4-a794-00163e937b17.html</a></p>
<p>Note that since <code>receive/2</code> and <code>send/2</code> are not available in the current version of Pengines, we have used <code>pengine_input/2</code>, <code>pengine_respond/2</code> and <code>pengine_output/1</code> instead, with the drawbacks mentioned earlier: a useless prompt plus that there is no way to send to this process if you have not created it yourself. More importantly, the semantics of <code>pengine_input/2</code> is different from the semantics of <code>pengine_receive/2</code>. It works in the case of our Scratchpad example, but that‚Äôs just an happy coincidence.</p>
<h3 id="a-universal-stateful-server-with-hot-code-swapping">A universal stateful server with hot code swapping</h3>
<p>This is how we can write a <em>generic</em> stateful server which can also handle hot code swapping:</p>
<pre><code class="prism language-prolog">server(Pred, State0) :-
   receive({
       new_pred(Pred1) -&gt;
           server(Pred1, State0);
       rpc(From, Query) -&gt;
           call(Pred, Query, State0, Answer, State),
           send(From, Answer),
           server(Pred, State)
   }).
</code></pre>
<p>Here‚Äôs the client code:</p>
<pre><code class="prism language-prolog">rpc(To, Query, Val) :-
   self(Self),
   send(To, rpc(Self, Query)),
   receive({
       Val -&gt; true
   }).
</code></pre>
<p>Here‚Äôs an <em>example</em> of what can be used to specialise the generic server:</p>
<pre><code class="prism language-prolog">fridge(store(Food), FoodList, ok, [Food|FoodList]).
fridge(take(Food), FoodList, ok(Food), FoodListRest) :-
   select(Food, FoodList, FoodListRest), !.
fridge(take(Food), FoodList, not_found, FoodList).
</code></pre>
<p>Note that the specialisation also makes the decision to use list s the datastructure for holding the food.</p>
<p>We start with a empty fridge.</p>
<pre><code class="prism language-prolog">?- spawn(server(fridge, []), Pid),
   rpc(Pid, store(cheese), Val1),
   rpc(Pid, store(meat), Val2),
   rpc(Pid, take(cheese), Val3),
   rpc(Pid, take(cheese), Val4).

Val1 = ok,
Val2 = ok,
Val3 = ok(cheese),
Val4 = not_found.
</code></pre>
<p>When we program we want to structure the code into ‚Äúdifficult‚Äù and ‚Äúeasy‚Äù modules. The difficult modules should be few and written by expert programmers. The easy modules should be many and written by less experienced programmers.</p>
<p>The OTP framework provides an abstraction layer on top of erlang. It defines applications, which have well defined initialization and stop points, that can depend on other applications. It also has abstractions for a number of special type of processes, among them:</p>
<p>Supervisors: Processes that watch over other processes and handle their failures. Child processes may in turn be supervisors themselves, forming a process hierarchy.</p>
<p>Generic servers: Processes that handle requests, which can be synchronous or asynchronous.</p>
<p>State machines: Processes that live in one of a finite number of states and respond to events in possibly different ways depending on the current state.</p>
<p>The above are called OTP behaviors. Normally you would create a module and mark it as an implementation of one of these behaviors, then implement the callbacks (‚Äúhooks‚Äù in Prolog parlance) required by that behavior. This saves you from reinventing the wheel, but you need to familiarize yourself with what is required to implement each behavior and when to expect the OTP framework to call your callback functions.</p>
<h3 id="concurrency">Concurrency</h3>
<p>A we noted before, although concurrent programming with pengines is clearly possible, it hasn‚Äôt undergone any validation to speak of, and therefore this possibility is still underexploited. In contrast, Erlang has for a long time been used and therefore also been validated as a powerful tool for concurrent programming. Small, medium and large applications have been built, pitfalls have been located, tools and practices have been developed, and books and tutorials have been written. For this reason alone it is probably a good idea to borrow from Erlang as much as possible.</p>
<p>It is easy to run several processes in parallell in Erlang, and to allow them to communicate with each other. In the following example ‚Äì given in both Erlang and Web Prolog ‚Äì two processes are first created and then start sending messages to each other a specified number of times.</p>
<p>The different status messages are as follows:</p>
<pre><code>true
    The goal has been proven successfully.
false
    The goal has failed.
exception(Term)
    The thread has been terminated on an exception. 
exited(Term)
    The thread is terminated on thread_exit/1 using the argument Term.
</code></pre>
<p>In Erlang the corresponding messages are all of the form <code>{down, Ref, Pid, Reason}</code>. For Web Prolog, the exact form of such messages would need to be determined, but I think it would work fine with the above ones.</p>
<p>Using an extra Prolog thread here seems like a wasteful overkill. Possibly a class of <em>dedicated</em> monitor threads could be introduced and given a low-level C implementation?</p>
<p>See the section about the implementation of <code>pengine_rpc/3</code> for an example of the use of <code>monitor/1</code>.</p>
<p>Erlang has other features that would be nice and perhaps even necessary to have in Web Prolog. For example, Erlang has a <code>link/1</code> function that allows the linking of one process to another, so that (for example) if one process dies, the process linked with it will die too. As we have already remarked, Pengines, as implemented in <code>library(pengines)</code>, are <em>always</em> linked in this way: if the process that created a pengine dies, the pengine will die too. This is not always what we want. For other kinds of applications you may want to have unlinked pengines that do just that: hang around waiting for input from anyone who knows their Pid<img draggable="false" class="emoji" alt="üòí" src="https://twemoji.maxcdn.com/36x36/1f612.png"> and who can use <code>send(Pid, Term)</code> in order to send messages to them. For Web Prolog, we need a more flexible scheme, where the required behavior can be specified programmatically. Therefore, we would like to suggest that we borrow from Erlang here too, and introduce at least the following predicates into Web Prolog:</p>
<ul>
<li>link/1</li>
<li>spawn_link/{2,3}</li>
<li>unlink/1</li>
<li>process_flag(trap_exit, true)</li>
</ul>
<p>Without these, it is probably impossible to build an OTP-like library of behaviors.</p>
<p>I have a small and very sketchy implementation, available here:‚Ä¶</p>
<h3 id="web-prolog-and-pengines-v2-use-cases-1">Web Prolog and Pengines V2 use cases</h3>
<p>Web Prolog concentrates on software systems that</p>
<ul>
<li>are <em>Web-based</em>, and</li>
<li>need <em>knowledge representation and reasoning</em>, and/or</li>
<li>are <em>reactive</em> in the sense of the <em>Reactive Manifesto</em> (see <a href="http://www.reactivemanifesto.org">http://www.reactivemanifesto.org</a>).</li>
</ul>
<p>This may be seen as too narrow, but it‚Äôs not.</p>
<p>My hope is that the logic programming aspects of Web Prolog can be made to co-exist harmoniously with its reactive aspects, such as processes and process communication. Both should be usable in the same program, with processes (e.g. pengines) used for modelling the reactive interfaces to the user and other external entities, and with the non-deterministic component behaving as a process, encapsulating the non-determinism.</p>
<p>Erlang‚Äôs contribution here concerns the <em>flow control and the orchestration/choreography of concurrent and possibly distributed processes</em> using message passing.</p>
<blockquote>
<p>[Erlang] provides an architectural infrastructure ‚Äî we can organize our system as a set of communicating processes. By enumerating all the processes in our system, and defining the message passing channels between the processes we can conveniently partition the system into a number of well-defined sub-components which can be independently implemented, and tested.</p>
</blockquote>
<blockquote>
<p>You see, links are more of an organizational construct. When you design the architecture of your application, you determine which process will do which jobs, and what will depend on what. Some processes will supervise others, some couldn‚Äôt live without a twin process, etc. This structure is usually something fixed, known in advance. Links are useful for that and should not necessarily be used outside of it.</p>
</blockquote>
<p>The <em>combination</em> of logic-based knowledge representation, reasoning, flow control and the orchestration of concurrent processes is very powerful. Great for building e.g. dialogue systems. Active databases.</p>
<p>Some of the use cases for the Semantic Web are surely also use cases for the Prolog Web. They may not be many, but I would be surprised if they didn‚Äôt exist at all. Databases, expert systems, AI.</p>
<ul>
<li>
<p>Prolog as data querying and transformation tool</p>
</li>
<li>
<p>NoSQL databases. Couchdb built on Erlang, Web Prolog built on Erlang.</p>
</li>
<li>
<p>Holding on to the focus on the Web</p>
</li>
<li>
<p>Most cases for Prolog are covered; exceptions are found where there is a dependency on features lacking from Web Prolog, in particular features that are unsafe.</p>
</li>
<li>
<p>All use cases for Erlang are <em>not</em> covered by Web Prolog. Programming telephone switches is certainly one that isn‚Äôt.</p>
</li>
<li>
<p>SWISH is a use case for pengines. Pengines is a use case for Web Prolog. Ergo, SWISH is a use case for Web Prolog. So is ClioPatria, in the sense that an even more capable ClioPatria could conceiveably be built in Web Prolog.</p>
</li>
<li>
<p>We may want to describe the Prolog Web as a use case for Web Prolog. This does of course beg the question, of what use is the Prolog Web?</p>
</li>
<li>
<p>It may be that the advent of multi-core computers will make Prolog obselete if it doesn‚Äôt move in the direction of somehow make use of it. The high-end Mac Pro comes with 6 cores, and there are mobile phones that have 8 and even 10 cores.</p>
</li>
</ul>
<h4 id="computational-linguistics-1">Computational linguistics</h4>
<p>Computational linguists would be disappointed if Web Prolog didn‚Äôt provide improvements in their area of application. After all, computational linguistics was one of the initial motivation behind Prolog. I have selected a couple of things that I think blends in particularly well with the syntax and semantics of Prolog.</p>
<p>In a term-based formalism, the structure of a category is determined by the predicate symbol, the arguments, and the order of the arguments. In a feature-structure based formalism, the structure of a category is defined by its features and their values. The value of a feature may be any element, either atomic or complex.</p>
<p>The following is a so called unification-based grammar for a tiny fragment of English. The variables are supposed to be instantiated to so called <em>feature structures</em>, that in our case would be dicts that are ‚Äúsideways open‚Äù (in a way to be explained). The actual example is borrowed from Stuart Shieber, see <a href="https://dash.harvard.edu/handle/1/11576719">https://dash.harvard.edu/handle/1/11576719</a>:</p>
<p>To make this work, we need a data structure similar to dicts, but but they must be ‚Äúsideways open‚Äù in the sense that Jan describes here:</p>
<blockquote>
<p><strong>Note</strong> In the current implementation, two dicts unify only if they have the same set of keys and the tags and values associated with the keys unify. In future versions, the notion of unification between dicts could be modified such that two dicts unify if their tags and the values associated with common keys unify, turning both dicts into a new dict that has the union of the keys of the two original dicts.</p>
</blockquote>
<p>Json Unification</p>
<p>Assuming that we use sideways open dicts and that <code>===/2</code> is a unification operator for such dicts we can use them when parsing and generating with ordinary DCGs. Consider a grammar where the use of feature structures guarantees number agreement between the subject and the verb of a sentence.</p>
<pre><code>s(S) --&gt; np(NP), vp(VP), {
    S:head === VP:head,
    S:head:subject === NP:head
}.

vp(VP) --&gt; v(V), {
    VP:head === V:head
}.

np(NP) --&gt; [uther], {
    NP:head:agreement:number === singular,
    NP:head:agreement:person === third
}.

v(V) --&gt; [sleeps], {
    V:head:form === finite,
    V:head:subject:agreement:number === singular,
    V:head:subject:agreement:person === third
}.

v(V) --&gt; [sleep], {
    V:head:form === finite,
    V:head:subject:agreement:number === plural
}.
</code></pre>
<p>Here is how the grammar could be used for parsing:</p>
<pre><code>?- phrase(s(S), [uther, sleeps]).
S = fs{head:fs{form:finite,
               subject:fs{agreement:fs{number:singular,
                                       person:third
                                      }
                         }
              }
      }.
      
?- phrase(s(S), [uther, sleep]).
false
</code></pre>
<p>As is usually the case with DCG, and to the detriment of natural language grammar engineers, one needs to avoid left recursive rules such as <code>s --&gt; s, [and] s</code> and <code>np --&gt; np, pp</code> that cause non-termination. In the precence of <em>tabling</em> there would no longer be a reason to do so, and parsing would be an O(n^3) process, which is the best one can hope for.</p>
<p>With this in the language we would certainly have a grammar formalism prettier that DCG and much prettier and more useful than for example W3C‚Äôs <em>Speech Recognition Grammar Specification</em> (SRGS), an XML-based formalism for writing small domain specific grammars that often go under the name of ‚Äúsemantic grammars‚Äù.</p>
<p>I don‚Äôt think people should use this approach for large NLP grammars though. For ‚Äúreal‚Äù NLP grammars one would rather use an adapter to a system such as Grammatical Framework (GF) which comes with grammar resources for more than 35 languages. See <a href="http://www.grammaticalframework.org/">http://www.grammaticalframework.org/</a> for more information.</p>
<p>The next item on my wish list is <em>compositional semantic interpretation</em> in the tradition of Richard Montague.</p>
<pre><code class="prism language-prolog">s(NP@VP) --&gt; np(NP), vp(VP).

np(PN) --&gt; pn(PN).

vp(TV@NP) --&gt; tv(TV), np(NP).

pn(lambda(P,P@sas)) --&gt; [sas].
pn(lambda(P,P@boston)) --&gt; [boston].
pn(lambda(P,P@714)) --&gt; [flight, 714].

tv(lambda(P,lambda(X,P@lambda(Y,serves(X,Y))))) --&gt; [serves].
</code></pre>
<p>Consider the first rule:</p>
<pre><code>s(NP@VP) --&gt; np(NP), vp(VP).
</code></pre>
<p>This rule says that the semantic representation for a sentence consisting of a noun phrase and a verb phrase is obtained by combining the semantic representation for the noun phrase (NP) with the semantic representation for the verb phrase (VP) using the operator ‚Äò@‚Äô, which is our way of representing the application of a lambda term to an argument.</p>
<p>Here is what parsing and semantic interpretation would look like:</p>
<pre><code>?- s(_S,[sas,serves,boston],[]), beta_convert(_S,S).
S = serves(sas,boston).
?-
</code></pre>
<p>One thing that probably led many computational linguists to abandon Prolog was the advent of <em>statistical methods</em> for NLP some fifteen years ago. I know very litte about probabilistic logic programming, but I suppose it could be useful for the purpose of mixing logic and statistical methods. Probabilistic grammars comes to mind.</p>
<p>NLTK</p>
<p>The CLASP project.</p>
<h4 id="web-based-multimodal-dialog-systems-1">Web-based multimodal dialog systems</h4>
<blockquote>
<p><em>Content is king</em>. (Bill Gates, 1996)<br>
<em>Conversation is king. Content is just something to talk about</em>. (Cory Doctorow, 20??)</p>
</blockquote>
<p>I‚Äôm going to start with the area of <em>dialogue systems</em>, simply because this is an area that I myself have worked in. It is easy to get bogged down in details here, and it‚Äôs good to once in a while remind ourselves of our vision, a Prolog Web in the form of a network of Prolog predicates, and a Web capable of talking also to humans. I use the word ‚Äútalking‚Äù here for a specific reason, having to do with my background in spoken dialogue system research. The future Spoken Web, filled with speech enabled applications such as mobile assistants ‚Äì think Apple‚Äôs Siri or Google Now ‚Äì assisting with the communication of the knowledge of the network to humans. Needless to say, they will rely on speech recognition and speech synthesis as well as natural language understanding and generation.</p>
<p>Driven in particular by the Mobile Web, the Spoken Web is almost here. I write ‚Äúalmost‚Äù since not every browser has the speech technologies ready. Google‚Äôs WebSpeech API is implemented by Chrome, and Nuance Communications, a big player in the speech technlogy industry, is able to serve developers with speech recognition and speech synthesis. See <a href="http://nuancemobiledeveloper.com">http://nuancemobiledeveloper.com</a>.</p>
<p>To control the interaction between such components, between the mobile assistant and the Prolog Web, and in particular between the mobile assistant and a human user, a so called <em>dialog manager</em> is needed. The following figure gives a hint of an architecture of a multimodal dialogue system:</p>
<p><img src="https://i.imgur.com/daKqGEm.png" alt="enter image description here"></p>
<p>A central role in the architecture is taken up by the <em>dialogue manager</em>, the component of a dialog system responsible for the state and flow of the conversation, and often the only component that is stateful.</p>
<p>It is often a good idea to run components concurrently and use asynchronous message passing to enable them to communicate. It doesn‚Äôt really matter if components are implemented in Web Prolog or not, since a non-Prolog component can always be proxied by a pengine ‚Äì a kind of adapter between a set-at-a-time cursor-limit based interface and a one-tuple-at-a-time interface if you want.</p>
<p>Use DCG for writing semantic grammars for parsing and understanding as well as for generating natural language. Perform semantic and pragmatic interpretation of the terms representing meaning of utterances against the context of world- and situation knowledge. Use the message passing capabilities provided by <code>send/2</code> and <code>receive/2</code> to implement simple as well as sophisticated dialogue management strategies, such as information-state based strategies or SCXML. I have it from late Scott McGlashan (personal communication) that message passing (event handling) was what made VoiceXML into a workable standard.</p>
<p>Timing is important in dialogue systems.</p>
<p>I would like to convince our NLP colleagues Johan Bos, Patrick Blackburn and Kristina Striegnitz that a ‚Äúfull stack‚Äù dialogue system can be built in a uniform language, taking care of things like parsing, generation, semantic interpretation, dialogue management, knowledge representation and reasoning, and, relying on the availability of JavaScript speech API<img draggable="false" class="emoji" alt="üòí" src="https://twemoji.maxcdn.com/36x36/1f612.png"> in browsers, speech recognition and synthesis.</p>
<p>Interaction part written in JavaScript. Web Prolog for sophisticated interaction., controlled on the server side. Listening, thinking, talking‚Ä¶</p>
<p>‚Äúlinguistic interaction needs intelligence‚Äù</p>
<p>The interaction demands intelligence, the ability to interact appropriately to speech acts given the context in question. Part of the context is obviously so called ‚Äúworld knowledge‚Äù, perhaps in a fairly closed domain, but still, something that we will not be able to store in the client.</p>
<p>Another thing is architecture. Sophisticated conversational agents. Galaxy Communicator. Scxml.</p>
<p>SCXML ‚Äì referera till tyskarnas f√∂rs√∂k att anv√§nda Prolog</p>
<p>Here, we are inspired by Fernandez &amp; Endriss (2007) who build an hierarchy of abstract models for protocols that takes as a starting point protocols based on deterministic finite automata.</p>
<p><img src="https://i.imgur.com/ep4zFMS.png" alt="enter image description here"></p>
<h4 id="graphical-user-interfaces-1">Graphical user interfaces</h4>
<p>That the interaction offered by spoken dialogue systems is conversational is something that can‚Äôt really be denied. But the same goes for graphical user interfaces in my opinion. They too are conversational. A stance like this can also be found in the user interface/HMI literature. In an interesting paper, Brennan (1990) advocates a pragmatics approach to human-computer interaction. Her view is that:</p>
<blockquote>
<p>[‚Ä¶] thinking of user interfaces in terms of real conversation leads to more specific predictions about how people will behave and to more informative explanations of why interface features succeed or fail. The hope is that employing the conversation metaphor will lead to insights in the kinds of architectures and features that are necessary to support cooperation between people and computers.</p>
</blockquote>
<p>The notion of conversation may seem to stand in some kind of opposition to the notion of direct manipulation. However, as studies of face-to-face communication clearly show, conversation usually involves not only words, but also pointing gestures, nods, eye-to-eye contact, um humns, sign language, etc. Moreover, communication most often takes place in the context of some activity involving non-communicative acts as well. I agree with Brennan when she claims that:</p>
<blockquote>
<p>[‚Ä¶] the dichotomy between direct manipulation and conversation is a false one [‚Ä¶] First, direct manipulation interfaces succeed because they share important features with real conversations. Second, when so called ‚Äúconversational‚Äù interfaces fail, it is because they lack these pragmatic features ‚Äì- that is, words alone do not a conversation make. Third, real conversations actually fulfil many of the criteria for direct manipulation.</p>
</blockquote>
<p>By looking at the interaction between the user and the system as a conversation, we are free to apply maxims of cooperative communication (Grice, 1975; Allwood, 1976), and on such grounds design the most efficient and cooperative dialogue possible.</p>
<p>For example, it seems natural to implement the control of what happens between starting and the quitting an application as a conversation, or perhaps a sequence of conversations.  SWISH is a good example. SWISH is actually a multi agent  dialogue application since a user may interact with (by default) three sessions concurrently, shifting attention from one to another at will.</p>
<h4 id="card-based-user-interfaces-1">Card-based user interfaces</h4>
<p><a href="https://blog.intercom.io/why-cards-are-the-future-of-the-web/">https://blog.intercom.io/why-cards-are-the-future-of-the-web/</a><br>
<a href="http://ben-evans.com/benedictevans/2013/6/18/canvases">http://ben-evans.com/benedictevans/2013/6/18/canvases</a></p>
<p>An interface built on Bootstrap <em>cards</em>, ideal for the conversation with a mobile device. The idea would be to use cards as the pengine‚Äôs contributions to the dialogue between the user and a running pengine. Not in the same way as SWISH uses its runners though, were each runner ‚Äúcard‚Äù corresponds to a pengine. Instead, each <em>system contribution</em>, of which there may be many in the conversation with a pengine, is given as a card. So <code>pengine_input/2</code> and <code>pengine_output/1</code> have roles to play here.</p>
<p>Card expert system<br>
Card interface to Markus‚Äô tutoring system</p>
<h4 id="robot-programming-1">Robot programming</h4>
<p>In a series of papers, Di Stefano et al. (?) argue for the use of Erlang for autonomous robot programming.</p>
<blockquote>
<p>[‚Ä¶] it is quite clear that developing software for such kind of robots requires to combine artificial intelligence (AI) concerns, needed to perform perception and adaptation, with motion driving aspects, which are instead typical of control systems. From the same as programming languages point of view, AI aspects for adaptation, like automated reasoning or planning, are usually faced with logic or functional languages, such as Prolog or LISP; on the other hand, motion driving is, in general, a matter of imperative approaches, like C/C++ or assembly, or even Java for low-level/embedded system programming.</p>
</blockquote>
<blockquote>
<p>The Erlang language and the OTP system, thanks to the syntax and programming model, exhibit some characteristics that fit well both of the aspects above: Erlang is functional and somewhat imperative, moreover recent research advances have proved its effectiveness also for AI programming [‚Ä¶], mainly thanks to the ability of handling symbolic/structured data and expressing production rules as function clauses.</p>
</blockquote>
<h4 id="games-1">Games</h4>
<p>Web-based, playcanvas, Web-based and mobile games is big industry.</p>
<h4 id="home-automation-1">Home automation</h4>
<p>Web Prolog, with it‚Äôs markedly rule based flavor is, as far as I can see, perfect for home automation. Maybe with one process per device, modeling external devices, sending incoming sensory data from Things as messages to be sent to parts of the system (other processes, some of them pengines) that decides how to react to them. The other way around, ‚Ä¶The Web of Prolog becomes also a <em>Web of Things</em>.</p>
<p>Actually, I have started to replace most of my lamp bulbs at in my department with Philips Hue light bulbs. I plan to build a demo in my home, on top of my private Prolog Web of Things. Philips Hue has a great API.</p>
<p><a href="http://smarthome.geekster.com">http://smarthome.geekster.com</a><br>
<a href="http://coliveira.net/software/why-learning-prolog-can-make-you-a-better-programmer/">http://coliveira.net/software/why-learning-prolog-can-make-you-a-better-programmer/</a><br>
<a href="http://swi-prolog.iai.uni-bonn.narkive.com/E9TpCWOs/prolog-as-a-control-point-of-a-distributed-system-using-corba">http://swi-prolog.iai.uni-bonn.narkive.com/E9TpCWOs/prolog-as-a-control-point-of-a-distributed-system-using-corba</a><br>
<a href="http://kylecordes.com/2010/the-prolog-story">http://kylecordes.com/2010/the-prolog-story</a><br>
<a href="http://www.cs.ru.nl/~peterl/teaching/KeR/assign1-2012.pdf">http://www.cs.ru.nl/~peterl/teaching/KeR/assign1-2012.pdf</a><br>
<a href="http://www.cs.ru.nl/~peterl/teaching/KeR/">http://www.cs.ru.nl/~peterl/teaching/KeR/</a></p>
<p><a href="https://nebrios.com/blog/software-list-iot-automationworkflow-rule-engines">https://nebrios.com/blog/software-list-iot-automationworkflow-rule-engines</a></p>
<p><a href="http://youtu.be/ELq8Vd30_H8">http://youtu.be/ELq8Vd30_H8</a></p>
<h4 id="expert-systems-1">Expert systems</h4>
<p>There was a time when expert systems was a big thing. One text book concentrates on this (Merrit, 19??), and</p>
<p>Expert systems never really went anywhere, and expert systems in Prolog, using the quite elegant meta-interpreter approach, never really went anywhere either. Speech technology may well give expert systems a push forward, and if so, Web Prolog will be ready for the challenge.</p>
<p>A new boom for expert systems, triggered by among other things speech technology and multimodal technology.</p>
<p>Here‚Äôs a link to a tiny expert system example, just to demo the interaction with a Web browser:</p>
<p><a href="http://pengines.swi-prolog.org/apps/scratchpad/index.html#1c12c372-8714-11e5-be28-00163e8fc784.html">http://pengines.swi-prolog.org/apps/scratchpad/index.html#1c12c372-8714-11e5-be28-00163e8fc784.html</a></p>
<p>ProbLog, CLP, Bayesan networks</p>
<h4 id="digital-humanities-1">Digital humanities</h4>
<p>Cliopatria</p>
<p>TagLog</p>
<p>There are also the new areas of <em>digital humanities</em> and <em>digital social science</em> that may be able to attract new groups of users.</p>
<h4 id="domain-specific-languages-1">Domain Specific Languages</h4>
<p>A domain-specific language (DSL) is a programming language (or specification language) of limited expressiveness focused on a particular application domain. Regular expressions and CSS are often used as examples of DSL<img draggable="false" class="emoji" alt="üòí" src="https://twemoji.maxcdn.com/36x36/1f612.png">.</p>
<p>Add distfix operators.</p>
<p>PSG Lab</p>
<h4 id="research-demos-1">Research demos</h4>
<p>Talks, tutorials and demos</p>
<h3 id="the-idea-1">The idea</h3>
<ul>
<li>The features inspired by Erlang provide processes and message passing programming.</li>
<li>Message passing programming is exactly what we need to implement a Prolog Web.</li>
<li>Message passing programming is exactly what we need to implement control abstractions for agents, dialogue systems, robots, etc.</li>
</ul>
<h4 id="logic-and-protocols-1">Logic and Protocols</h4>
<p>Behind all this is a beautiful separation of logic and control Communication protocols are different from APIs in the sense that a protocol may involve not only two dialogue partners but three or more.</p>
<p>Strengthen the procedural side of Prolog, the ability to define protocols.</p>
<h2 id="programming-examples-1">Programming examples</h2>
<p>Programming examples using Prolog rather than SPARQL. Refer to paper by Wielemaker et al.</p>
<p>This section present a number of programming example. Some of them show that Web Prolog programs can be written in the style of Erlang, whereas others show how to deal with the non-determinism that is not present at all in Erlang.</p>
<p>Note that some examples are very sketchy, in particular the ones towards the end of the section. They have not been tested.</p>
<h3 id="spawning-sending-and-receiving-2">Spawning, sending and receiving</h3>
<p>In Erlang, the <code>spawn</code> family of functions are higher-order functions. In Prolog it is better to refer to <code>spawn/2</code> as a <em>meta-predicate</em>.</p>
<p>Let us start by spawning a very simple function performing a very simple computation that determines the length of the list <code>[a ,b, c]</code>. In Erlang:</p>
<pre class=" language-erlang"><code class="prism  language-erlang"><span class="token number">1</span><span class="token operator">&gt;</span> <span class="token variable">Pid</span> <span class="token operator">=</span> <span class="token function">spawn</span><span class="token punctuation">(</span><span class="token keyword">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token atom">a</span><span class="token punctuation">,</span> <span class="token atom">b</span><span class="token punctuation">,</span> <span class="token atom">c</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">end</span><span class="token punctuation">)</span><span class="token punctuation">.</span>
&lt;<span class="token number">0.34</span><span class="token punctuation">.</span><span class="token number">0</span><span class="token operator">&gt;</span>
</code></pre>
<p>In Web Prolog we spawn a predicate/procedure instead, using a query (goal) rather than a function call:</p>
<pre><code class="prism language-prolog">?- spawn(length([a, b, c], N), Pid).
Pid = 3456.
</code></pre>
<p>Note that with neither the Erlang call nor the Prolog call is a result returned, just a Pid. (In the Prolog call the goal was copied, so the variable <code>N</code> wasn‚Äôt bound.) The result is computed all right, but the spawned process holds on to it and doesn‚Äôt share it with anything or anyone else. In both Erlang and Web Prolog we have to do two things in order to report the result:</p>
<ol>
<li>Instruct the process to send the result back to the calling process (as given by the function <code>self/0</code> and the predicate <code>self/1</code>).</li>
<li>See to it that this result is removed from the message queue of the calling process, and then printed.</li>
</ol>
<p>In Erlang:</p>
<pre class=" language-erlang"><code class="prism  language-erlang"><span class="token number">1</span><span class="token operator">&gt;</span> <span class="token variable">Self</span> <span class="token operator">=</span> <span class="token function">self</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> 
   <span class="token variable">Pid</span> <span class="token operator">=</span> <span class="token function">spawn</span><span class="token punctuation">(</span><span class="token keyword">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token variable">N</span> <span class="token operator">=</span> <span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token atom">a</span><span class="token punctuation">,</span> <span class="token atom">b</span><span class="token punctuation">,</span> <span class="token atom">c</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token variable">Self</span> <span class="token operator">!</span> <span class="token variable">N</span>  <span class="token keyword">end</span><span class="token punctuation">)</span><span class="token punctuation">,</span> 
   <span class="token keyword">receive</span> <span class="token variable">M</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token atom">io</span><span class="token punctuation">:</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token variable">M</span><span class="token punctuation">)</span> <span class="token keyword">end</span><span class="token punctuation">.</span>
3ok
</code></pre>
<p>Also in Erlang, but in the more concise functional style:</p>
<pre class=" language-erlang"><code class="prism  language-erlang"><span class="token number">1</span><span class="token operator">&gt;</span> <span class="token variable">Self</span> <span class="token operator">=</span> <span class="token function">self</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> 
   <span class="token variable">Pid</span> <span class="token operator">=</span> <span class="token function">spawn</span><span class="token punctuation">(</span><span class="token keyword">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token variable">Self</span> <span class="token operator">!</span> <span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token atom">a</span><span class="token punctuation">,</span> <span class="token atom">b</span><span class="token punctuation">,</span> <span class="token atom">c</span><span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token keyword">end</span><span class="token punctuation">)</span><span class="token punctuation">,</span> 
   <span class="token keyword">receive</span> <span class="token variable">M</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token atom">io</span><span class="token punctuation">:</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token variable">M</span><span class="token punctuation">)</span> <span class="token keyword">end</span><span class="token punctuation">.</span>
3ok
</code></pre>
<p>In Web Prolog:</p>
<pre><code class="prism language-prolog">?- self(Self), 
   spawn((length([a, b, c], N), Self ! N), Pid), 
   receive({ M -&gt; writeln(M) }).
3
Self = main,
Pid = 3456, 
M = 3.
</code></pre>
<p>In Erlang, a process is spawned with a function to be executed. This function determines what the process will do when it runs, for example what forms of messages it will listen for, what forms of messages will be passed to other processes, and what it will compute there in between. I may be an simple function that only sends back the result of performing a very simple computation such as computing the lengt of a list. That too is behaviour, just not very interesting. There are much more interesting cases, where for example an Erlang process is used for the orchestration of a bigger network of Erlang processes, i.e. as a controller of other processes (which may in term be controllers of yet other processes). Such functions usually don‚Äôt evaluate to anything that would make us think of functions in the mathematical sense.</p>
<p>A computation server for computing the length of lists is silly too, but it shows the idea.</p>
<pre><code class="prism language-prolog">start :-
   spawn(server, Pid).

server :-
   receive({
       compute(Pid, L) -&gt;
           length(L, N),
           send(Pid, len(N))
   }),
   server.
</code></pre>
<p>This is an example of a <em>stateless</em> server.</p>
<h3 id="stateful-servers-1">Stateful servers</h3>
<p>The following example, borrowed from Fred H√©bert‚Äôs excellent Erlang book, shows how an agent can be made to hold state and update it during a conversation.</p>
<p>The code creates a process allowing two operations: storing food in the fridge and taking food from the fridge. It should only be possible to take food that has been stored beforehand. With the help of recursion, the state to a process can be held entirely in the parameters of the function/arguments of the predicate. In this case we choose to store all the food as a list, and then look in that list when someone needs to eat something.</p>
<p><img src="https://i.imgur.com/Eu58jL8.png" alt="enter image description here"></p>
<p>In the Prolog version (to the right) I have done my best to emphasise the similarity with Erlang, by using terms such as <code>{From, {store, Food}}</code> and an infix <code>!</code> for sending, just like in Erlang.</p>
<p>The following is a better implementation in Web Prolog:</p>
<pre><code class="prism language-prolog">fridge(FoodList) :-
   receive({
       store(From, Food) -&gt;
           send(From, ok),
           fridge([Food|FoodList]) ;
       take(From, Food) -&gt;
           (   select(Food, FoodList, FoodList1)
           -&gt;  send(From, ok(Food)),
               fridge(FoodList1)
           ;   send(From, not_found),
               fridge(FoodList)
           ) ;
       terminate -&gt;
           true
   }).
</code></pre>
<p>This kind of mutable state you get in Web Prolog is exactly the same you get in Erlang, nothing less, nothing more, which is usually via processes and you need to send messages to change or read from the process state. There are other ways to implement mutable state in Prolog ‚Äì by means of assert and retract for example, or by means of nb_set/2 and nb_get/2. One potentially important advantage of using a process as a mutable state is that it can be made distributed.</p>
<h3 id="current-fridge-is-broken-1">Current fridge is broken</h3>
<p>As yet another illustration of the shortcomings of the current version of Pengines, we have translated a simple Erlang program into Prolog and made it available in the Scratchpad:</p>
<p><a href="http://pengines.swi-prolog.org/apps/scratchpad/index.html#5fbd7b66-2be0-11e4-a794-00163e937b17.html">http://pengines.swi-prolog.org/apps/scratchpad/index.html#5fbd7b66-2be0-11e4-a794-00163e937b17.html</a></p>
<p>Note that since <code>receive/2</code> and <code>send/2</code> are not available in the current version of Pengines, we have used <code>pengine_input/2</code>, <code>pengine_respond/2</code> and <code>pengine_output/1</code> instead, with the drawbacks mentioned earlier: a useless prompt plus that there is no way to send to this process if you have not created it yourself. More importantly, the semantics of <code>pengine_input/2</code> is different from the semantics of <code>pengine_receive/2</code>. It works in the case of our Scratchpad example, but that‚Äôs just an happy coincidence.</p>
<h3 id="a-universal-stateful-server-with-hot-code-swapping-1">A universal stateful server with hot code swapping</h3>
<p>This is how we can write a <em>generic</em> stateful server which can also handle hot code swapping:</p>
<pre><code class="prism language-prolog">server(Pred, State0) :-
   receive({
       new_pred(Pred1) -&gt;
           server(Pred1, State0);
       rpc(From, Query) -&gt;
           call(Pred, Query, State0, Answer, State),
           send(From, Answer),
           server(Pred, State)
   }).
</code></pre>
<p>Here‚Äôs the client code:</p>
<pre><code class="prism language-prolog">rpc(To, Query, Val) :-
   self(Self),
   send(To, rpc(Self, Query)),
   receive({
       Val -&gt; true
   }).
</code></pre>
<p>Here‚Äôs an <em>example</em> of what can be used to specialise the generic server:</p>
<pre><code class="prism language-prolog">fridge(store(Food), FoodList, ok, [Food|FoodList]).
fridge(take(Food), FoodList, ok(Food), FoodListRest) :-
   select(Food, FoodList, FoodListRest), !.
fridge(take(Food), FoodList, not_found, FoodList).
</code></pre>
<p>Note that the specialisation also makes the decision to use list s the datastructure for holding the food.</p>
<p>We start with a empty fridge.</p>
<pre><code class="prism language-prolog">?- spawn(server(fridge, []), Pid),
   rpc(Pid, store(cheese), Val1),
   rpc(Pid, store(meat), Val2),
   rpc(Pid, take(cheese), Val3),
   rpc(Pid, take(cheese), Val4).

Val1 = ok,
Val2 = ok,
Val3 = ok(cheese),
Val4 = not_found.
</code></pre>
<p>When we program we want to structure the code into ‚Äúdifficult‚Äù and ‚Äúeasy‚Äù modules. The difficult modules should be few and written by expert programmers. The easy modules should be many and written by less experienced programmers.</p>
<p>The OTP framework provides an abstraction layer on top of erlang. It defines applications, which have well defined initialization and stop points, that can depend on other applications. It also has abstractions for a number of special type of processes, among them:</p>
<p>Supervisors: Processes that watch over other processes and handle their failures. Child processes may in turn be supervisors themselves, forming a process hierarchy.</p>
<p>Generic servers: Processes that handle requests, which can be synchronous or asynchronous.</p>
<p>State machines: Processes that live in one of a finite number of states and respond to events in possibly different ways depending on the current state.</p>
<p>The above are called OTP behaviors. Normally you would create a module and mark it as an implementation of one of these behaviors, then implement the callbacks (‚Äúhooks‚Äù in Prolog parlance) required by that behavior. This saves you from reinventing the wheel, but you need to familiarize yourself with what is required to implement each behavior and when to expect the OTP framework to call your callback functions.</p>
<h3 id="concurrency-1">Concurrency</h3>
<p>A we noted before, although concurrent programming with pengines is clearly possible, it hasn‚Äôt undergone any validation to speak of, and therefore this possibility is still underexploited. In contrast, Erlang has for a long time been used and therefore also been validated as a powerful tool for concurrent programming. Small, medium and large applications have been built, pitfalls have been located, tools and practices have been developed, and books and tutorials have been written. For this reason alone it is probably a good idea to borrow from Erlang as much as possible.</p>
<p>It is easy to run several processes in parallell in Erlang, and to allow them to communicate with each other. In the following example ‚Äì given in both Erlang and Web Prolog ‚Äì two processes are first created and then start sending messages to each other a specified number of times.</p>
<p><img src="https://i.imgur.com/vgRNt6V.png" alt="enter image description here"></p>
<h3 id="non-determinism">Non-determinism</h3>
<p>It is wise to entertain a suspicion of unexpected interactions between language features and possible impedance mismatches between the two paradigms ‚Äì between Prolog‚Äôs relational, non-deterministic programming model and Erlang‚Äôs process and message passing model. Can we really avoid the Lego-Meccano situation in this case? How well do these Erlang-ish constructs mix with Prolog, with backtracking for example? As we shall see, one of the necessary tricks is to allow (the action part) of a receive to <em>fail</em> and, by failing, force backtracking.</p>
<p>Let us assume that we are actually happy with the api that Pengines V1 has.</p>
<h4 id="warming-up">Warming up</h4>
<p>Suppose the query given in the argument to <code>spawn/2</code> has more than one answer, a query such as <code>member(X, [a,b])</code> for example. The code below will compute and then report only the first answer.</p>
<pre><code class="prism language-prolog">?- self(Self), 
  spawn(
       (   member(X, [a,b]), 
           send(Self, X)
       ), Pid), 
  receive({ M -&gt; writeln(M) }).
a
Self = main,
Pid = 2345, M = a.
</code></pre>
<p>If we instead use receive in order to listen for a message of the form <code>next</code> or <code>stop</code> before terminating we can do something like this:</p>
<pre><code class="prism language-prolog">?- self(Self), 
  spawn(
       (   member(X, [a,b]), 
           send(Self, X), 
           receive({next -&gt; fail; stop -&gt; true})
       ), Pid), 
  receive({ M1 -&gt; writeln(M1) }),
  receive({ M2 -&gt; writeln(M2) }).
a
b
Self = main,
Pid = 2345, 
M1 = a, 
M2 = b.

</code></pre>
<p>This will work in the sense that it first will print ‚Äòa‚Äô. It will then wait for a message coming from another process. If this message is ‚Äònext‚Äô, backtracking will take place, ‚Äòb‚Äô will be generated and printed, and at this point the variable bindings will also be written. This demonstrates that Prolog‚Äôs backtracking behaviour is perfectly compatible with the proposed Erlang-like mechanism. However, if the message is ‚Äòstop‚Äô, no more answers will be sent and the spawned process will terminate. The parent process will however not terminate, since the second receive will be waiting for a message to arrive.  Obviously, we will have to build something more generic.</p>
<p>Pengines is a software abstraction that can be built on top of <code>spawn/2</code>, <code>send/2</code> and <code>receive/2</code>. Browser Api, Parallell processing, Distributed processes, they all make use of <code>spawn/2</code>, <code>send/2</code> and <code>receive/2</code>. The browser is capable of using it too. Later we‚Äôll see that we can build another abstraction on top of pengines, the RPC mechanism. Abstractions such as these can be compared to Erlang‚Äôs <em>behaviors</em>. They are difficult to build, but once they are built they can be fairly easily instantiated and tailored to specific tasks.</p>
<h4 id="the-plap-protocol-the-pengines-protocol">The PLAP protocol (The Pengines Protocol)</h4>
<p>Underlying the design of the Pengines package is an analysis of the conversations taking place between Prolog and a user (which could be a human or another piece of software). Such conversations follow a communication protocol that we refer to as the Prolog Application Protocol (PLAP). The protocol is based on the Prolog 4-port model, (Byrd 1980) extended with exceptions and I/O and has been modelled by means of so called communicating finite-state machines (Brand and Zafiropulo 1983). A slight modification of the protocol, referred to as PLAP<sub>HTTP</sub>, makes it compatible with HTTP, where only the client can take initiative. Figure 1 depicts the communicating finite-state machines for PLAP<sub>HTTP</sub> and HTTP. Labels in bold indicate requests, and labels with a slash in front indicate responses.</p>
<p><img src="https://i.imgur.com/roTdXly.jpg" alt="enter image description here"></p>
<p>From the diagram, we can read off the following properties:</p>
<ul>
<li>No matter the current state, <strong>abort</strong> will take us to the initial idle state.</li>
<li>An unrecognized message will emit a <strong>protol error</strong>, but will not cause a change of states.</li>
<li>A query may be issued, not only in state <strong>2</strong>, but also in state <strong>5</strong></li>
<li>In the event of <strong>ask n</strong> or <strong>next n</strong>, n refers to the number of solutions being asked for.</li>
</ul>
<p>Lager and Wielemaker (2014) implemented this protocol on top of HTTP.</p>
<p>This is exactly how the current implementation of pengines works. In a future implementation using Websockets, the <strong>pull_response</strong> command can be replaced with an epsilon transition.</p>
<p>We believe our work can be viewed more abstractly, as a description of a general approach to web logic programming, that can be given a concrete manisfestation not only for Prolog but also for other one-tuple-at-a-time logic programming languages.</p>
<h4 id="implementing-pengines-in-web-prolog">Implementing Pengines in Web Prolog</h4>
<p>It will likely be (much?) easier to implement Pengines in Web Prolog than in SWI-Prolog, especially since distribution is built-in already at the level of Web Prolog.</p>
<p>As far as I can see now, an implementation in Web Prolog will also handle all the shortcomings of Pengines V1.</p>
<pre><code>pengine_create(NodeURL, Pid) :-
   self(Self),
   spawn(NodeURL, loop(Pid, Self), Pid).

loop(Pid, Parent) :-
    receive({  
        ask(Query) -&gt;
            ask(Query, Pid, Parent),
            loop(Pid, Parent);
        destroy -&gt;
            send(Parent, destroy(Pid))    
    }). 

ask(Query, Pid, Parent) :-
   (   call_cleanup(Query, Det=true)
   -&gt;  (   var(Det)
       -&gt;  send(Parent, success(Pid, Query, true)),
           receive({   
               next -&gt; fail;
               stop -&gt; 
                  send(Parent, stop(Pid))
           })
       ;   send(Parent, success(Pid, Query, false))
       )
   ;   send(Parent, failure(Pid))
   ). 
</code></pre>
<p>Something annoying with the pengines is that the programmer who‚Äôs going to use them has to know about the protocol that‚Äôs been invented for them. A good way to solve this is to abstract messages away ‚Äì hiding them ‚Äì with the help of predicates dealing with sending (and receiving?) them:</p>
<pre><code>pengine_ask(Pid, Query) :- send(Pid, ask(Query)).

pengine_next(Pid) :- send(Pid, next).

pengine_stop(Pid) :- send(Pid, stop).
</code></pre>
<p>So given:</p>
<pre><code>:- module(a, [q/1]).

q(X) :- p(X).

p(a).
p(b).
</code></pre>
<p>we can have the following interaction:</p>
<pre><code>?- pengine_create('http://ex.org#a', Pid).
Pid = 123@'http://ex.org#a'.
?- send(123@'http://ex.org#a', ask(q(_X))). 
true.
?- receive({M -&gt; writeln(M)}).
success(123@'http://ex.org#a‚Äô, q(a), true)
true.
?- send(123@'http://ex.org#a', next).
true.
?- receive({M -&gt; writeln(M)}).
success(123@'http://ex.org#a', q(b), false)
true.
</code></pre>
<h3 id="when-to-use-a-pengine">When to use a pengine?</h3>
<p>For deterministic goals, you want to use <code>spawn/2</code>. The typical use here is to call a procedure that will specify the behaviour of the process thus created, the kind of messages it will listen for, and what kind of messages will be sent to other pengines. In other words, how it will interact with other processes, including human. A backtrackable process, i.e. a pengine, should only be invoked when calling a non-deterministic goal. Likely, <code>spawn/2</code> should spawn goals using <code>once(Goal)</code>.</p>
<h3 id="implementing-ndrpc">Implementing NDRPC</h3>
<p>Let us return to the Prolog Web and to a sketch for a Pengines V2 implementation of <code>pengine_rpc/2</code>.</p>
<pre><code>pengine_rpc(NodeURL, Query) :-
    self(Self),
    pengine_create(NodeURL, Pid),
    monitor(Pid),
    pengine_ask(Pid, Query),
    wait_answer(Query, Pid).

wait_answer(Query, From) :-
   receive({
       true -&gt; true;
       false -&gt; fail;
       exit(_) -&gt; true;              
       exception(Exception) -&gt; 
           throw(Exception);                  
       success(_, Answer, true) -&gt; 
           (   Query = Answer
           ;   pengine_next(From), 
               wait_answer(Query, From)
           );
       success(_, Answer, false) -&gt; 
           Query = Answer,
           wait_answer(Query, From)
   }).
</code></pre>
<p>Note that the patterns on the left hand side of the top four PCA rules correspond to four different status messages, one of which will eventually be produced by the call to <code>monitor/1</code>. Note also that the fifth rule, with pattern <code>success(_, Answer, true)</code>, has a non-deterministic action by means of which backtracking will be ‚Äúconverted‚Äù into a command <code>next</code>.</p>
<p>So given the same program as above, we can have an interaction like so:</p>
<pre><code>?- pengine_rpc('http://ex.org#a‚Äô, q(X)).
X = a ;       
X = b.
</code></pre>
<h3 id="non-prolog-pengines">Non-Prolog pengines</h3>
<p>It might make sense to give APIs to services from Google, Twitter, etc. an interface based on pengines, an interface that takes care of the translation of a Prolog query into an HTTP request (often the API is RESTful), sends the HTTP request, knows what to do if the service is down, translates the result returned (usually provided as JSON) into Web Prolog, returns of the result on backtracking, and so on.</p>
<p>One could be written for RDFa!</p>
<p>It has to run in its own thread since the Prolog client is synchronous.</p>
<p>One nice thing about this is that it is likely that these interfaces are going to look and behave fairly similar to each other. It may well be possible to implement an Erlang-ish <em>behaviour</em> that can be instantiated for different services.</p>
<p>Another nice thing about this is that having pengines do this will automatically pay off also for the level above. Using <code>pengine_rpc/3</code> will just work, being ignorant of the fact that it is not really dealing with Web Prolog.</p>
<h2 id="designing-web-prolog">Designing Web Prolog</h2>
<p>As alwys, we need to strike a balance between simplicity, expressiveness, and efficiency. We know that the expressiveness required by knowledge and information processing applications can be found within Prolog‚Ä¶</p>
<p>It must be said that there is nothing that forces us to implement Pengines and <code>pengine_rpc/3</code> the way that we have done here. It‚Äôs just nice to be able to. It‚Äôs not even clear that <code>pengine_rpc/3</code> should be a library predicate. Probably not. But then we will have two built-in predicates for spawning a process.</p>
<p>The different levels provide us with an interesting ‚Äúdesign space‚Äù for the specification of Web Prolog, perhaps suggesting that the best design may be found where the code implementing pengines on top of Erlang-inspired predicates such as <code>spawn/2,3</code>, <code>send/2</code> and <code>receive/2</code>, as well as the code implementing the Prolog Web on top of the pengines, will appear as simple and elegant as possible.</p>
<h2 id="learnability">Learnability</h2>
<p>The fact that Web Prolog is a combination two very mature programming languages should make it relatively easy to learn, even when documentation is lacking.</p>
<p>The two languages mix very nicely syntactically as well as semantically, and they also complement each other very well. There should be, we argue, no surprises for a developer familiar with both Prolog and Erlang. People like Joe Armstrong and Robert Virding, Erlang experts who are also very familiar with Prolog, will probably know right away how to program effectively with predicates such as <code>spawn/3</code>, <code>send/2</code> and <code>receive/2</code> in Web Prolog. The differences with Erlang are few and easy to understand.</p>
<p>An Erlang programmer with very little experience with Prolog should still feel fairly at home with the syntax but might be uncomfortable at first with the non-functional notation and with the non-deterministic behaviour of Prolog. For a Prolog programmer with little or no experience with Erlang (or with threaded Prolog), problems such as deadlocks and race conditions may be new. For such a programmer, it should be reassuring that the very existence of Erlang and its big fan base can be seen as a proof of the fact that such problems can be overcome by skilled and motivated programmers.</p>
<p>There are at least half a dozen books about Erlang available, and a really nice one on the Web:</p>
<ul>
<li>Fred H√©bert. Learn You Some Erlang for Great Good!<br>
<a href="http://learnyousomeerlang.com">http://learnyousomeerlang.com</a></li>
</ul>
<p>Prolog programmers probably need to read only the chapters about concurrent programming, and if they don‚Äôt plan to use Erlang-ish features they don‚Äôt even need to do that. If you come from the Erlang side it is probably more difficult to learn Prolog, but not as hard as for those that come from an imperative background. Besides, there are plenty of Prolog text books around, and most of them are free. Here is a list:</p>
<ul>
<li>Patrick Blackburn, Johan Bos, and Kristina Striegnitz. Learn Prolog Now! An introduction to Prolog programming.<br>
<a href="http://www.learnprolognow.org/lpnpage.php?pageid=online">http://www.learnprolognow.org/lpnpage.php?pageid=online</a></li>
<li>Michael A. Covington, Donald Nute, and Andr√© Vellino, Prolog Programming in Depth, Second edition, Prentice-Hall, 1997<br>
<a href="http://www.covingtoninnovations.com/books/PPID.pdf">http://www.covingtoninnovations.com/books/PPID.pdf</a></li>
<li>Michael A. Covington. Natural Language Processing for Prolog Programmers, Prentice-Hall, 1994.<br>
<a href="http://www.covingtoninnovations.com/books/NLPPP.pdf">http://www.covingtoninnovations.com/books/NLPPP.pdf</a></li>
<li>Bart Demoen, Phuong-Lan Nguyen, Tom Schrijvers, Remko Tron√ßon, The First 10 Prolog Programming Contests<br>
<a href="https://dtai.cs.kuleuven.be/ppcbook/">https://dtai.cs.kuleuven.be/ppcbook/</a></li>
<li>Peter Flach, Simply Logical: Intelligent Reasoning by Example, John Wiley 1994, xvi + 240 pages, ISBN 0471 94152 2<br>
<a href="http://www.cs.bris.ac.uk/~flach/SimplyLogical.html">http://www.cs.bris.ac.uk/~flach/SimplyLogical.html</a></li>
<li>Gerald Gazdar and Chris Mellish, Natural Language Processing in Prolog,<br>
<a href="https://tinyurl.com/p459746">https://tinyurl.com/p459746</a></li>
<li>Dennis Merritt. Building Expert Systems in Prolog.<br>
<a href="http://www.amzi.com/ExpertSystemsInProlog">http://www.amzi.com/ExpertSystemsInProlog</a></li>
<li>Dennis Merritt. Adventure in Prolog.<br>
<a href="http://www.amzi.com/AdventureInProlog">http://www.amzi.com/AdventureInProlog</a></li>
<li>Fernando C. N. Pereira and Stuart M. Shieber, Prolog and Natural-Language Analysis.<br>
<a href="http://mtome.com/Publications/PNLA/pnla.html">http://mtome.com/Publications/PNLA/pnla.html</a></li>
</ul>
<p>We still need to write a new book though, or a tutorial.</p>
<h2 id="implementations">Implementations</h2>
<p>Dedicated Prolog systems such as SWI-Prolog or SICStus Prolog are usually written in fairly low-level languages such as C or C++. However, one commonly come across Prolog implementations also in highlevel languages such as Scala, Python, Haskell, Erlang, Lisp and Scheme. I find this interesting, and I suppose that it could mean that programmers using such languages once in a while come across use cases where Prolog would be nice to have available.</p>
<p>It furthermore makes it reasonable to assume that Web Prolog can be implemented on top of any of these languages. This is what the following diagram tries to convey:</p>
<p><img src="https://i.imgur.com/aQkTcKC.png" alt="enter image description here"></p>
<p>The consequence for portability will be as follows: An application written in a combination of (say) Erlang and Web Prolog will not be portable to (say) the SWI-Prolog environment. However, an application written in pure Web Prolog will not only be portable in the normal sense, but you will likely also be able to run it on a server that you do not own nor manage.</p>
<p>Different Web Prolog nodes may implement different ‚Äúprofiles‚Äù (fragments or a sublanguages) of the Web Prolog language, each of which achieves efficiency in a different way and is useful in different application scenarios.</p>
<p>Make the Prolog part as <em>pure</em> as possible:</p>
<ul>
<li>Implement <code>\=/2</code> as <code>dif/2</code></li>
<li>Use CLP(FD) constraints for all integer arithmetic.</li>
</ul>
<p>It means that we need a way for a Web Prolog node to announce its capabilities, the profile(s) it supports.</p>
<h3 id="summary-of-implementation-in-swi-prolog">Summary of implementation in SWI-Prolog</h3>
<p>The present version of <code>library(pengines)</code> is implemented on top of <code>thread_*</code> predicates and the HTTP libraries. The Prolog Web is implemented on top of <code>library(pengines)</code>.</p>
<p>My suggestion is that we instead implement the Erlang-ish primitives on top of <code>thread_*</code> predicates and the Websockets library, and that we build a new implementation (in the form of a library or as a built-in ‚Äì I‚Äôm not sure what would be best here) in Web Prolog. Then the Prolog Web can be based on this implementation instead and other Erlang/OTP style <em>behaviours</em> can be built on top of Erlang-ish primitives + Prolog.</p>
<p>As have been demonstrated, it is possible to implement spawn, send and receive on top of Prolog‚Äôs thread predicates. It is not optimal since the underlying processes will be threads rather than the super lightweight processes of Erlang. This will change, not the semantics, but the <em>pragmatics</em> of the language ‚Äì what you can do with it. Web Prolog can probably be implemented on top of Erlang too.</p>
<p>I don‚Äôt think it is possible to implement Web Prolog with HTTP as the transport layer, except possibly by using a greedy long polling strategy or something like that. With Websockets as the transport layer should be possible though.</p>
<p>I suggest that an explorative implementation be done in SWISH in the following steps:</p>
<ol>
<li>Implement <code>spawn/2</code> and <code>spawn/3</code> in terms of <code>pengine_create/1</code>. This has been (partly) done.</li>
<li>Implement <code>receive/2</code>. This has been done.</li>
<li>Implement <code>send/2</code> (!).</li>
<li>We also need an output predicate that is able to print directly to the output area, not only from the toplevel pengine, but also from slaves to the toplevel pengine. This is only reasonable to do for local pengines?</li>
</ol>
<h3 id="swi-prolog-roadmap">SWI-Prolog roadmap</h3>
<p>On 23 October 2013, in an attempt to attract sponsors, Jan wrote the following to the SWI-Prolog mailing list:</p>
<p>[‚Ä¶]<br>
Many of you have a wishlist. At this moment, there are several options<br>
to get grants for further development if there is co-sponsering from<br>
commercial users or -in some cases- merely a statement that ‚Äúthis<br>
feature would be of great help for my business‚Äù. Even without grants,<br>
it may be interesting for you to join forces and sponsor development.<br>
[‚Ä¶]<br>
Below are some projects that are in the waiting queue, just to give<br>
you an idea.  I‚Äôm seeking for ways to get these things realised<br>
quicker than doing it myself next to other obligations.</p>
<ul>
<li>Tabling.  Most will know what it is ‚Ä¶</li>
<li>Porting probabilistic extensions (e.g., ProbLog).  Requires tabling.</li>
<li>Performance enhancements.  It will be hard to beat YAP, but it should<br>
be fairly easy to get significant improvements.</li>
<li>Deep indexing (i.e., indexing into term arguments).</li>
<li>Well integrated debugging and analysis tools (notably typing, mode and<br>
determinism).</li>
<li>Web-based development tools.</li>
<li>Transaction based database.  Useful for dynamic code, can also<br>
provide controlled hot-swapping of code in multi-threaded servers.</li>
<li>Cleanup goal-expansion.  Provide inline predicates and partial evaluation.</li>
<li>Enhance scaling multi-threading, notably by reducing locking.</li>
<li>Establish tutorial material aiming at SWI-Prolog‚Äôs extensions and<br>
libraries.</li>
<li>Improve the manual and website (get Anne‚Äôs work finished)</li>
<li>RDF support enhancements: faster reload, improve query optimization,<br>
notably for queries that involve literals.</li>
</ul>
<p>Some of these enhancements have already been implemented, and all of the remaining ones are perfecly in line with the development of Web Prolog. However, I think that instead of establishing ‚Äútutorial material aiming at SWI-Prolog‚Äôs extensions and libraries‚Äù, we should develop tutorial material aiming at Web Prolog. For one thing, it will be much easier, and will naturally include a fair number of SWI-Prolog‚Äôs extensions and libraries, but will be packaged as language features rather than libraries. A text book might be the best option here.</p>
<p>Jan shouldn‚Äôt have to do the JavaScript programming himself. The best would be if he concerned himself with the standard and with the implementation of e.g. tabling in SWI-Prolog. The Web Prolog community needs a couple of good front-end developers. We might want to recruit the on for example <a href="openhatch.org">openhatch.org</a>. The community around Elixir is a good example. We also need people to write a book introducing Web Prolog.</p>
<h4 id="my-own-suggestions">My own suggestions:</h4>
<ul>
<li>Prolog Notebooks need to support MathJax.</li>
<li>Build generic Android and iPhone apps with speech recognition and synthesis already built in.</li>
</ul>
<h3 id="in-erlang">In Erlang</h3>
<p>An implementation in Erlang would be interesting since it would most probably have a performance profile different from the implementation in SWI-Prolog. Prolog is likely to be slower in Erlang than in the implementation in SWI-Prolog, whereas the super fast lightweight processes in Erlang have other advantages, making it scale better to very many simultaneous users on a network.</p>
<p>Interestingly, there is already a Prolog implementation in Erlang, written by Robert Virding, one of the people behind Erlang. Also, the people behind Erlog seem to have come up with a way to pass messages between Erlang and Erlog, witness the following quote (from Stackoverflow):</p>
<blockquote>
<p>We are working on building the 1.0 release of Erlog, a prolog that can run in an Erlang process. For now I have implemented the ability to send and receive Messages via the normal erlang mechanisms.</p>
</blockquote>
<p>A link to Erlog is provided here: <a href="https://github.com/rvirding/erlog">https://github.com/rvirding/erlog</a>.</p>
<p>Getting Armstrong and/or Virding interested in Web Prolog would be a boon. I‚Äôm not sure they are completely happy with Elixir (though Armstrong gives it a very positive <a href="http://joearms.github.io/2013/05/31/a-week-with-elixir.html">review</a>), since in all likelyhood, Elixir will be (or already is?) more popular than Erlang, and if Elixir takes over, the beautiful Erlang-ish syntax will live on only in Prolog. It may well be that they would like to take their ideas in the direction of Web Prolog too. This may be interesting also from a language evolution point of view.</p>
<p>The best way to implement Web Prolog on top of the Erlang VM might be to transpile Web Prolog source code into a combination of Erlang and Erlog? That too may well have disadvantages. A future cooperation between Erlang implementers and Prolog implementers might be able to come up with a way to work around such disadvantages. It‚Äôs payback time, Erlang ‚Äì you got some good stuff from Prolog, and now Prolog wants some good stuff from you in return!</p>
<p>Note also that Erlang is particularly famous for extremely efficient implementations of Web-related technologies such as Web servers (e.g. Yaws and Cowboy).</p>
<h3 id="in-java">In Java</h3>
<h2 id="standardisation">Standardisation</h2>
<p>A good programming language standard makes writing portable programs possible ‚Äì provided that the standard covers all the features used by the program, and that implementations conform to the standard.</p>
<p>The current ISO standard for Prolog has failed in the sense that few existing Prolog systems of today are conformant, but also due to the fact that most Prolog system go far beyond the standard in some respects. This has made porting Prolog programs somewhat difficult. SWI-Prolog is one of the systems that doesn‚Äôt really conform, a fact lamented by some people, witness the following quote from a mail message sent to the SWI-Prolog mailing list from Markus Triska:</p>
<blockquote>
<p>[I am] extremely reluctant to depart from ISO conforming syntax when there are acceptable alternatives. Many of us work in environments where using anything that is not codified in industrial standards is completely out of the question for legal and insurance reasons alone, so I try to stick with ISO wherever possible, also in the interest of portability between different Prolog systems. For many of us, there will come days where we wonder if our whole program would not be much faster in YAP or SICStus, and it is often useful to have an alternative system in reach. Currently, the dict syntax in SWI breaks even the canonical syntax. If you work in a highly regulated environment, a system with such a property will not be taken seriously, even if it is very useful at places that are less regulated. (Markus Triska, in a mail message dated ??)</p>
</blockquote>
<p>Here is the response by Jan:</p>
<blockquote>
<p>The ISO core is great to have, but too small, too much bound by poor decisions from the past (e.g., numbers and text) and impossible to evolve. Ideally we‚Äôd have a more flexible and wider adopted standardisation effort. All attempts in that direction failed due to lack of commitment and time as well as a wide variation in the focus of the various systems. (Jan, in a mail message dated ??).</p>
</blockquote>
<p>Here‚Äôs my take on this: If we really need to conform to a standard in order to attract users ‚Äúworking in a regulated environment‚Äù, and if the current ISO standard is impossible to evolve, then is seems we need a <em>new</em> standard, incorporating things like unicode, proper strings and the SWI-Prolog dicts. This would eventually, at least in principle, satisfy the demand for a standard posed by lawyers and insurance companies, and at the same time allow us to evolve the Prolog language. For industrial users, the <em>prospect</em> of a future standard is likely to be enough to increase trust.</p>
<p>Creating a new standard makes a lot of sense in the case of SWI-Prolog since, in the interest of evolving the language, several steps away from the ISO standard has already been taken. Not having to always defend any future move away from the ISO standard would probably also be a relief. In other words, working <em>towards</em> a new standard is a lot more fun than working <em>against</em> an already established one.</p>
<p>Also, the Web ‚Äì our focus in this proposal ‚Äì thrives on standards, and if we want maximal impact, we ought to present Web Prolog as a standard, but this time, as a Web standard.</p>
<p><a href="https://en.m.wikipedia.org/wiki/World_Wide_Web_Consortium">https://en.m.wikipedia.org/wiki/World_Wide_Web_Consortium</a></p>
<p>I have the impression that creating a W3C standard is somewhat easier than creating an ISO standard. All that is needed is a good design, lots of tests, and two implementations (from different organisations) that pass the tests. If design mistakes or errors of omission were made, a new version may be released that corrects them. (Which may of course lead to problems with backwards compatibility.)</p>
<p><a href="https://open-stand.org">https://open-stand.org</a><br>
<a href="https://open-stand.org/resources/#video">https://open-stand.org/resources/#video</a></p>
<p>The W3C reliance of tests suits SWI-Prolog. Jan‚Äôs comment to a mail message questioning this reliance:</p>
<blockquote>
<p>Well, this is how 95% of SWI-Prolog has always been developed. I fear it is the only way to make rapid progress with limited resources. Using a reactive development model we manage to build and maintain a big system with only a few people that satisfies the requirements of many.</p>
</blockquote>
<p>One possible point of departure is to create a W3C Community Group. According to <a href="https://www.w3.org/community/">their homepage</a>:</p>
<p>A W3C Community Group is an open forum, without fees, where Web developers and other stakeholders develop specifications, hold discussions, develop test suites, and connect with W3C‚Äôs international community of Web experts.</p>
<p><img src="https://i.imgur.com/95FUOIS.png" alt="enter image description here"></p>
<p>Interestingly, there is an already existing group that seems to partly fit our purposes (although it hasn‚Äôt been active at all):</p>
<blockquote>
<p><strong>The Semantic Web Programming Languages Community Group</strong><br>
A community focused on the adoption of Semantic Web concepts within contemporary and new programming languages. These will incorporate W3C Semantic Web standards for Ontology, Linked data and representations as integral parts of the development tool chains. Particularly the group will aim to 1. Develop new semantically-aware programming languages, 2. Modify existing languages to be semantically-aware 3. Develop design patterns for semantically-aware programming. 4. Develop Ontologies for computer programming concepts to allow inter-lingual sharing of basic and domain-specific algorithms.</p>
</blockquote>
<p>I suggest we make Jan into a dictator. We all know that he always listens carefully before making decisions, and besides, he deserves to be the dictator.</p>
<p>Jan will be appointed Benevolent Dictator. This is to avoid the stalemate so common in the development of committee-based languages. In the next phase however, when we are in a W3C working group, it might be more problematic to have a dictator running the show. Our case, when presented in front of the W3C, needs to be very strong. We don‚Äôt want to spend more than (say) three years in this stage.</p>
<p><a href="http://www.drdobbs.com/architecture-and-design/in-praise-of-benevolent-language-dictat/231002535">http://www.drdobbs.com/architecture-and-design/in-praise-of-benevolent-language-dictat/231002535</a></p>
<hr>
<p>Profiles</p>
<p>ISO standards are paid for.</p>
<p>In the case of Web Prolog, the need for a standard is there, not so much for the sake of portability, but more for the sake of interoperability ‚Äì the ability of one implementation of Web Prolog to send code to as well as query other implementations of Web Prolog.</p>
<p>Portability will be impossible to reach, since we are dealing with a language which is <em>by design</em> not able to a permanent change of states to a node.</p>
<p>Web Prolog programs may be run also on machines that you don‚Äôt own or manage. This is similar to JavaScript, except that JavaScript (normally) runs on the client and Web Prolog runs on a server.</p>
<p>We don‚Äôt need to standardize the whole lot in one go. We could start with just a subset of ISO-Prolog and the NDRPC predicate. The Erlang-ish predicates can appear later.</p>
<hr>
<p>Arguments for sticking to a standard:</p>
<ul>
<li>There are environments where using anything that is not codified in industrial standards is completely out of the question for legal and insurance reasons alone</li>
<li>For portability</li>
</ul>
<p>Arguments for what kind of standard:</p>
<ul>
<li>A standard needs to have ONE clear focus.</li>
</ul>
<p>If two interactive processes have a subset of a language and a workable subset of a protocol in common, they possess a certain degree of interoperability. The bigger the subsets, the higher the degree of interoperability. This is one reason why standards are needed.</p>
<p>Biljan Parsia as a Supporter:<br>
<a href="http://www.xml.com/pub/a/2001/04/25/prologrdf/index.html">http://www.xml.com/pub/a/2001/04/25/prologrdf/index.html</a></p>
<h2 id="the-pengines-v2-framework">The Pengines V2 framework</h2>
<p>I would like to start with a screen dump of SWISH borrowed from (Wielemaker et al, 2014).</p>
<p><img src="https://i.imgur.com/AepWfRv.png" alt="enter image description here"></p>
<ul>
<li>Pengines V2 home page</li>
<li>SWISH &amp; Scratchpad in SWISH (see also <a href="http://www.codeply.com">http://www.codeply.com</a>)</li>
<li>Notebook Editor on a separate page?</li>
<li>Login page</li>
<li>Dashboard</li>
<li>Presentation tool</li>
<li>Settings</li>
</ul>
<p>I would be in favour of using professionaly developed themes for both home page and dashboard. Responsiveness allows a good experience also on mobile devices. The dashboard comes with the possiblity of changing style (light or dark). I think users of SWISH should be given the same option and with colour scheme matching.</p>
<p>The cost is low, and as can be seen from <a href="http://themes.getbootstrap.com/pages/about-us">http://themes.getbootstrap.com/pages/about-us</a> the money spent is likely to support a good cause.</p>
<p><a href="http://themes.getbootstrap.com/products/marketing">http://themes.getbootstrap.com/products/marketing</a></p>
<ul>
<li><a href="http://www.scala-lang.org/">http://www.scala-lang.org/</a></li>
<li><a href="https://www.python.org/">https://www.python.org/</a></li>
<li><a href="https://www.haskell.org/">https://www.haskell.org/</a></li>
</ul>
<p><a href="http://themes.getbootstrap.com/products/dashboard">http://themes.getbootstrap.com/products/dashboard</a></p>
<p>Write to Bootstrap and ask about the license</p>
<p>To build web application on top of something like Cliopatria becomes much, much easier than to build your own stuff on top of a number of libraries. It has become a <em>framework</em>.</p>
<p>In the editor, I think you should be able to click the link present in a call to <code>pengines_rpc/3</code>. The effect should be any of these: 1) If the file is smaller than a couple of hundred lines, and if the owner of the Web Prolog server allows you to see it, a new tab opens in the editor and the file is shown. 2) If the file is larger than a couple of hundred lines, and if the owner of the Web Prolog server allows you to see it, a dialogue informs about this and ask you whether you want to see the whole file or just the first couple of hundred lines. 3) If the owner of the Web Prolog server doesn‚Äôt allow you to see the file, a dialogue informs you about this.</p>
<p>You are normally not allowed to edit the file, only to browse it.</p>
<p>This requires a slight change of the way in which a file on a server is pointed to. Because one Web Prolog server may support more than one app, a URI such as <code>http://example.org</code> will not be sufficient for pointing out the correct application module. We need to use something like <code>http://example.org#foo</code>, where <code>foo</code> is the name of the application and also the name of the module in which (some of) the Web Prolog code that drives the application resides. The <code>pengines_rpc/3</code> option <code>application(foo)</code> would no longer be needed and can be deprecated.</p>
<h2 id="branding">Branding</h2>
<h4 id="the-war-of-the-engines">The War of the Engines</h4>
<table>
<tbody><tr>
<td><img src="pengines_logo.png"></td><td><b>VS</b></td><td><img src="appengine_final2.png"></td>
</tr>
<tr>
<td>Pengines V2</td><td></td><td>Google App Engine</td>
</tr>
</tbody></table>
<h2 id="financing">Financing</h2>
<p>I will also go into the problem of financing something like this.</p>
<p>Companies should be more willing to sponsor our efforts if we show them that we are aiming at a standard.</p>
<p>Ghost running a hosting solution, micropayment or monthly. We could do the same.</p>
<p>crowd-funding software development see <a href="http://www.sitepoint.com/crowdfunding-software-project/">http://www.sitepoint.com/crowdfunding-software-project/</a></p>
<h2 id="creating-community">Creating community</h2>
<p>We should also allow ourself to be inspired by the development of Elixir and the enthusiasm surrounding its development.</p>
<h2 id="deliverables">Deliverables</h2>
<ul>
<li>A Web Prolog W3C standard</li>
<li>A Web Prolog implementations</li>
<li>A Web Prolog framework</li>
</ul>
<p>Web Prolog implementations can:</p>
<ul>
<li>execute Web Prolog</li>
<li>serve as a node in the Prolog Web</li>
</ul>
<p>The framework can:</p>
<ul>
<li>serve as a UI-server towards human users</li>
<li>will thus serve not only Prolog, but also JSON.</li>
</ul>
<h2 id="personal-committment">Personal committment</h2>
<p>I‚Äôm interested in actually help realizing this thing. What I would do first is to find out if people such as Joe Armstrong and Robert Virding like the idea. And Richard O‚ÄôKeefe should not be forgotten, he knows a lot about both languages.</p>
<p>I would then arrange a meeting.</p>
<p>I‚Äôm also willing to serve as the chair and editor of the standard. As mentioned above, I would like to appoint Jan Wielemaker dictator, at least as long as we are in the community group mode rather than in the working group mode.</p>
<p>Fixing the esthetic aspect of e.g. SWISH.</p>
<p>Writing papers.</p>
<p>Serve as an evangelist.</p>
<p>Create company.</p>
<h1 id="personal-plan">Personal plan</h1>
<ul>
<li>Create the group</li>
<li>‚Ä¶</li>
</ul>
<h2 id="references">References</h2>
<ul>
<li>
<p>Joe Armstrong (2003) Making reliable distributed systems in the presence of software errors</p>
</li>
<li>
<p>Brennan, S. E. (1990)  Conversation as Direct Manipulation: An Icono-clastic View. In B. Laurel (Ed.). <em>The Art of Human-Computer Interface Design</em>. Addison-Wesley.</p>
</li>
<li>
<p>Tim Berners-Lee, James Hendler, and Ora Lassila. The Semantic Web. Scientific American, May 2001.</p>
</li>
<li>
<p>Fred H√©bert. Learn You Some Erlang for Great Good!<br>
<a href="http://learnyousomeerlang.com">http://learnyousomeerlang.com</a></p>
</li>
<li>
<p>Tom Schrijvers (2007) A wake-up call for the Logic Programming community <a href="https://dtai.cs.kuleuven.be/projects/ALP/newsletter/dec07/content/Articles/tom/paper.pdf">https://dtai.cs.kuleuven.be/projects/ALP/newsletter/dec07/content/Articles/tom/paper.pdf</a></p>
</li>
<li>
<p>Tom Schrijvers and Bart Demoen (2008), Uniting the Prolog Community<br>
<a href="https://lirias.kuleuven.be/bitstream/123456789/197755/1/draft.pdf">https://lirias.kuleuven.be/bitstream/123456789/197755/1/draft.pdf</a></p>
</li>
<li>
<p>Pereira, F. C. N. &amp; Warren, D. H. D. (1980)  Definite Clause Grammars for Language Analysis - A Survey of the Formalism and a Comparison with Augmented Transition Networks. Artificial Intelligence 13(3), 231-278</p>
</li>
<li>
<p>Roy, Peter van (2009). Programming Paradigms for Dummies: What Every Programmer Should Know. In G. Assayag and A. Gerzso (eds.) New Computational Paradigms for Computer Music, IRCAM/Delatour, France.</p>
</li>
<li>
<p>Requirements Specification and Development Principles for Programming Languages. <a href="http://web.cs.mun.ca/~ulf/pld/analysis.html">http://web.cs.mun.ca/~ulf/pld/analysis.html</a></p>
</li>
</ul>
<h1 id="scrap">Scrap</h1>
<p>There is even a talk by Joe Armstrong on YouTube where he seems regretting removing too much from Prolog. <a href="http://youtu.be/h8nmzPh5Npg">Title</a>   40:17</p>
<p>BTW, don‚Äôt miss his talks, they are very enjoyable.</p>
<hr>
<p>Retrieve the text about purity by Markus<br>
dif should</p>
<p>You may regard it as my wishlist. I think the least we can do in return for Jan‚Äôs work is to have a wishlist.</p>
<p>DCG with dicts. Dicts as JSON.</p>
<p>Glue + architecture</p>
<p>Web programming options<br>
Options for spawn (invoke) and send</p>
<p>The leave-no-trace principle. When a process is dead the state should remain unchanged, except if the server provided ways to change it.</p>
<p>The tutorial ‚Äì genealogist</p>
<p>Tropo application</p>
<p>Data and Interacton<br>
Information and Interaction<br>
Logic and Interaction<br>
Knowledge and Interaction<br>
Logic and protocol</p>
<p>Want to learn more about Bloom, Dedalus, and BOOM? Visit the project website, or check out Hellerstein‚Äôs keynote from PODS 2010 (includes synchronized video and slides; over an hour long).</p>
<p>Web Prolog can be parsed with a normal Prolog parser.</p>
<p>Learnability ‚Äì is not going to lessen the difficulties with learning Prolog. But nor will it increase them. We are not looking for Learnability greater than Prolog. Web Prolog is not going to be easier than Prolog to learn, but not much harder either.</p>
<hr>
<p>Implementing <code>pengine_rpc/3</code> involves creating a remote pengine, which may send additional predicates to the remote server and subsequently realise the normal declarative and operational semantics of running a Prolog predicate by acting on the pengine events.</p>
<hr>
<p>Receive would be perfectly compatible with Pengines V1 (I know since I have tried), and would make a nice addition also to this library, should we choose not to implement full Web Prolog.</p>
<hr>
<p>SKRIV OM: A server may serve one or more <em>applications</em> (‚Äúnodes‚Äù). An application is implemented by the predicates exported by the application module in union with any program clauses contributed by the client when a server side process is created, as dictated by the client. A non-empty set of program clauses serves to specialise the process. The goal, also provided by the client, may specialise the process further.</p>
<hr>
<p>My version av bootstrap.<br>
Console<br>
Dashboard<br>
Jan gave, in a mail, a link to sample statistics</p>
<hr>
<p>Consider two programmers A and B. They decide to divide a programming task between them. B Is assigned the task of developing a predicate p/1, to be used in A‚Äôs program. If A inserts the following clause in his program we have arrived at a simple way of doing collaborative programming:</p>
<hr>
<p>Pontus W√§rnest√•l: Pro Bono Consultant ‚Äì see his LinkedIn page</p>
<hr>
<pre><code>
p(X) :- p(X) @ 'http://b.org'.

</code></pre>
<p>This would work even in the case of mutually dependent programs.</p>
<p>Stubs</p>
<hr>
<p>Sharing and collaboration are key for Pengines V2.</p>
<hr>
<p>SWISH: I have even tried to find a front-end developer that can help Jan with that.</p>
<hr>
<p>There is even an XML-format for feature structures. See [TEI standard for feature structures.<br>
<a href="http://www.dfki.de/~uschaefer/papers/09-lee.pdf">http://www.dfki.de/~uschaefer/papers/09-lee.pdf</a>](TEI standard for feature structures.<br>
<a href="http://www.dfki.de/~uschaefer/papers/09-lee.pdf">http://www.dfki.de/~uschaefer/papers/09-lee.pdf</a>].</p>
<hr>
<p><a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.104.4562&amp;rep=rep1&amp;type=pdf">http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.104.4562&amp;rep=rep1&amp;type=pdf</a></p>
<p>Peers share or exchange computer resources and services by direct exchange, i.e. there is a decentralization away from heavy-weight servers to equal-weight peers. The CPU cycles, disk storage, and files on a computer can be utilized by other peers leading to distributed storage which integrates the available disk space of a number of computers, distributed parallel processing, and distributed content management. Such decentralization can provide greater fault-tolerance since there is no single point of failure, distributed resource control and maintenance (e.g., distributed content management where individuals maintain the content they publish and have a sense of control over the content), greater efficiency of information exchange since traffic is not routed through central bottlenecks, and ease of set-up and usage which partly comes from distributed resource administration and in situ information sharing (e.g., information need not be transferred to<br>
another host such as a central server to be published). With content distributed among peers in a distributed network, mechanisms including protocols and query languages for performing searches over the distributed resources are an obvious need.</p>
<hr>
<p>Why design yet another programming language? Well, there is a sense in which Jan has already started to do so.</p>
<hr>
<p>Jan generally advice against embedding Prolog in X or the other way around as it is typically hard to get memory management and threading properly synchronized. Instead, if the latency and overhead of (de)serializing data is not prohibitive one should first consider using networking for communication between processes.</p>
<p>At the moment, there are clients for Prolog and JavaScript (including node.js). Based on the code of pengines.js, it should be pretty trivial to write clients for just about any other language that can act as HTTP client and has a JSON parser/writer.</p>
<blockquote>
<p>There are zillions of ways to make [processes] communicate over the network. Considering Pengines over HTTP would be my first option, being both simple and powerful.</p>
</blockquote>
<hr>
<blockquote>
<p>Many languages, typically found among the so called declarative languages in the functional and logical paradigms, lack proper models of state, thus crippling their interoperability with conventional languages, which rely on assignment to update data structures in a state.</p>
</blockquote>
<p>Prolog lacks the expressiveness of the process-oriented framework since it has no appropriate model of state and change and timing.</p>
<hr>
<p>Finally, we introduce a statement which builds lists from sequences of alternative results. It provides powerful means of interaction between determinate and nondeterminate code.</p>
<hr>
<p>Processes are expressed in a sequential logic programming language. The logic programming component is augmented with side effect operations such as creation of processes and message passing.</p>
<hr>
<p>Clausal syntax - same in Erlang and Prolog.</p>
<hr>
<p>pengine_event_loop vs receive .</p>
<hr>
<p>Blocking vs non-blocking I/O: <a href="http://stackoverflow.com/questions/1241429/blocking-io-vs-non-blocking-io-looking-for-good-articles">http://stackoverflow.com/questions/1241429/blocking-io-vs-non-blocking-io-looking-for-good-articles</a></p>
<hr>
<p>impress.js</p>
<hr>
<p>The world IS concurrent. It IS parallel. Things happen all over the place at the same time. I could not drive my car on the highway if I did not intuitively understand the notion of concurrency; pure message-passing concurrency is what we do all the time.</p>
<p>Imagine a group of people. They have no shared state.</p>
<p>I have my private memory (in my head) and you have yours. It is NOT shared. We communicate by passing messages (sound and light waves). We update our private state based on the reception of these messages.</p>
<p>Connect this to games!!!</p>
<hr>
<p>com<br>
Run test<br>
Signal test failures<br>
I really believe in tests.</p>
<p>Skriv till Christoffer. Om Prolog.<br>
Prolog course for employed.<br>
Write to Jan about exercises</p>
<p>I‚Äôm addressing people much brighter than myself, while I‚Äôm only dabbling in a field that really isn‚Äôt my own.</p>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p><a href="https://en.wikipedia.org/wiki/Technology_roadmap">https://en.wikipedia.org/wiki/Technology_roadmap</a> <a href="#fnref1" class="footnote-backref"><img draggable="false" class="emoji" alt="‚Ü©" src="https://twemoji.maxcdn.com/36x36/21a9.png"></a></p>
</li>
<li id="fn2" class="footnote-item"><p>Link to the talk <a href="#fnref2" class="footnote-backref"><img draggable="false" class="emoji" alt="‚Ü©" src="https://twemoji.maxcdn.com/36x36/21a9.png"></a></p>
</li>
<li id="fn3" class="footnote-item"><p><a href="http://erlang.org/pipermail/erlang-questions/2010-December/054881.html">http://erlang.org/pipermail/erlang-questions/2010-December/054881.html</a> <a href="#fnref3" class="footnote-backref"><img draggable="false" class="emoji" alt="‚Ü©" src="https://twemoji.maxcdn.com/36x36/21a9.png"></a></p>
</li>
</ol>
</section></div></body>
</html>